# MySQL+Redis读方案

![查询三部曲](./images/查询三部曲.png)

Redis和MySQL通常情况下都是按照上图步骤使用。

1. 先查询Redis，命中则直接返回给客户端。

2. Redis未命中，查询MySQL返回给客户端。

3. MySQL回写给Redis，保证下一次Redis中有数据。

**常规伪代码**

```go
func getData(int id) map[string]string {
    // 先查询Redis
    data := redis.Get(id)
    if len(data) == 0 {
        // Redis未命中去数据库中查询
        data = dao.Get(id)
        if len(data) == 0 {
            return nil
        } else {
            // 回写Redis
            redis.Set(id, data)
            return data
        }
    } else {
        // Redis命中直接返回
        return data
    }
}
```

**问题**

上面的代码正常情况下不会有问题，但在高并发场景下，如果Redis中无数据，此时又同时来了N个请求，当还没有从MySQL查询到数据写回到Redis时，N个请求直接打满MySQL。

**双检加锁策略**

针对上面的问题，在查询MySQL之前，增加互斥锁并再次对Redis进行查询，确保查询数据库只会有一次不会被打死。

```go
func getData(int id) map[string]string {
    // 先查询Redis
    data := redis.Get(id)
    if len(data) == 0 {
        // Redis未命中去数据库中查询
        // 先加一个排它锁，保证只有一个线程访问MySQL，未拿到锁的排队等待
        if lock.Lock() {
            // 二次查询保证排队等待锁的线程能够从Redis拿到数据
            data = redis.Get(id)
            if len(data) == 0 {
                data = dao.Get(id)
                if len(data) == 0 {
                    return nil
                } else {
                    // 回写Redis
                    redis.Set(id, data)
                return data
                }
            } else {
                return data
            }
        }
    } else {
        // Redis命中直接返回
        return data
    }
}
```

# 缓存双写一致性更新策略

当MySQL数据有更新，如何保持MySQL和Redis数据一致性？大概有这四种策略。

**先更新MySQL，再更新Redis**

```log
A、B两个线程发起调用

【正常逻辑】

1 A update mysql 100

2 A update redis 100

3 B update mysql 80

4 B update redis 80

====================================

【异常逻辑】多线程环境下，A、B两个线程有快有慢，有前有后有并行

1 A update mysql 100

3 B update mysql 80

4 B update redis 80

2 A update redis 100

====================================

【最终结果】mysql和redis数据不一致，mysql80,redis100。
```

无法保证数据一致性，不推荐。

**先更新Redis，再更新MySQL**

```log
A、B两个线程发起调用

【正常逻辑】

1 A update redis 100

2 A update mysql 100

3 B update redis 80

4 B update mysql 80

====================================

【异常逻辑】多线程环境下，A、B两个线程有快有慢有并行

A update redis  100

B update redis  80

B update mysql 80

A update mysql 100

====================================

【最终结果】mysql和redis数据不一致，mysql100,redis80
```

无法保证数据一致性，不推荐，且以Redis为准不太好。

**先删除Redis，再更新MySQL**

```log
A、B两个线程发起调用
A是写，B是读

【正常逻辑】

1 A delete redis

2 A update mysql 100

3 B get redis 空

4 B get mysql 100

====================================

【异常逻辑】多线程环境下，A、B两个线程有快有慢有并行

A delete redis

A update mysql 100 # 原来的值是80

B get redis 空

B get mysql 80 # A还未更新完，值还是80，B拿到80并回写到Redis

====================================

【最终结果】mysql和redis数据不一致，mysql100，redis80

====================================

【解决方案】--- 延迟双删策略
1. A线程先删除redis
2. A线程继续更新MySQL
3. A线程延时等待一段时间（估算为读线程读取数据并写入redis的时间+百毫秒），这是为了B线程读的时候能够读到数据并写入缓存
4. B线程从MySQL读错误数据并写入redis
5. A线程再将B线程写入的错误redis删除
6. 其他再进来的线程就能从数据库中读取到最新的数据
【问题】不能保证在A线程删除redis之前，进来的线程读取到的是正确的数据
【好处】能够保证删除Redis之后的数据是正确的。
```

如果要用此策略，必须要配合延迟双删策略来保证最终一致性。

**先更新MySQL，再删除Redis**

```log
A、B两个线程发起调用
A是写，B是读，C是读

【逻辑】

1 A update mysql 100

2 B get redis 80 # B 拿到老值

3 A delete redis

4 C get redis 空

5 C get MySQL 100

6 C set redis 100

【最终结果】mysql和redis数据最终是一致的，只是A删除redis之前，其他线程获取的是脏数据
```

此方案最推荐，简单+也保证了最终一致性。
