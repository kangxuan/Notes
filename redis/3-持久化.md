# Redis持久化

**为什么需要持久化**

Redis是存储在内存中的数据库，一旦重启服务或宕机会导致内存中的数据丢失，所以需要采用持久化功能将内存中的数据写入到磁盘，重新启动时恢复。

**持久化工具**

- RDB

- AOF

# RDB

**是什么**

RDB（Redis database）持久性以指定的时间间隔执行数据集的时间点快照，也就是把某一时刻的数据和状态以文件的形式写入磁盘。即使宕机，快照文件也不会丢失，来保证数据的可靠性。这个快照文件被称为RDB文件（dump.rdb）。

**自动触发**

- 修改配置

```shell
# Unless specified otherwise, by default Redis will save the DB:
#   * After 3600 seconds (an hour) if at least 1 change was performed
#   * After 300 seconds (5 minutes) if at least 100 changes were performed
#   * After 60 seconds if at least 10000 changes were performed
#
# You can set these explicitly by uncommenting the following line.
#
# save 3600 1 300 100 60 10000
save 5 2 # 如果发现有2次或以上的变更就触发一次自动保存
...
# The filename where to dump the DB
dbfilename dump6379.rdb # 修改rdb的名称方便
...
# Note that you must specify a directory here, not a file name.
dir /myredis/dumpfiles # 自定义rdb文件保存目录，这个目录要提前建好
```

- 重启redis

```shell
# 停掉redis
redis-cli -a 123 shutdown
# 启动redis
redis-server /myredis/redis.conf
```

- 可以通过命令查看配置

```shell
# config get 配置项
127.0.0.1:6379> config get dir
1) "dir"
2) "/myredis/dumpfiles"
```

- 触发备份

```shell
# 如果是5秒内，设置两个值，会立刻写入rdb
# 如果第一个在5秒内，第二个在5秒外，当第二个执行时就直接写入rdb，然后重新计时
127.0.0.1:6379> set k1 v1
OK
127.0.0.1:6379> set k2 v2
OK
```

- 如何恢复

```shell
# 模拟
# 1. 先将rdb重命名备份
mv dump6379.rdb dump6379.rdb.backup
# 2. flushdb清空库，此时会新生成rdb文件，但里面已经没有数据因为执行了flushdb，保持数据一致性
127.0.0.1:6379> flushdb
OK
127.0.0.1:6379> keys *
(empty array)
# 3. 重启redis
127.0.0.1:6379> shutdown
not connected> quit
redis-server /myredis/redis.conf
# 4. 没有数据，因为用的是清空数据库时候的rdb文件
127.0.0.1:6379> keys *
(empty array)
# 5. 将flushdb之前的rdb文件还原
rm dump6379.rdb
rm：是否删除普通文件 "dump6379.rdb"？y
mv dump6379.rdb.backup dump6379.rdb
# 6. 重启redis查看数据，已经恢复
127.0.0.1:6379> dbsize
(integer) 6
```

**手动触发**

有时候一些重要的数据写入，需要马上写入rdb，此时就需要手动触发。手动触发提供了两个命令save和bgsave。

- save
  
  - 在主程序中执行会阻塞当前redis服务，直到持久化工作完成。
  
  - 执行命令期间，redis不能处理其他命令。
  
  - 线上环境禁止使用
  
  ```shell
  127.0.0.1:6379> set k7 v7
  OK
  # 会立马将变更的数据写入rdb
  127.0.0.1:6379> save
  OK
  ```

- bgsave
  
  - 在后台异步进行快照操作，不阻塞，不影响Redis的其他命令。
  
  - gbsave会fork出一个和主进程一模一样的子进程进行持久化工作。
  
  - 在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，尽量避免膨胀。
  
  ```shell
  127.0.0.1:6379> set k8 v8
  OK
  127.0.0.1:6379> bgsave
  Background saving started
  # 可以通过lastsave查看最后一次save事件，自动触发也可以用
  127.0.0.1:6379> lastsave
  (integer) 1684587217
  ```

**优势**

- 适合大规模的数据恢复，很快，因为是快照。

- 可以业务调整定时备份。

- 对数据完整性和一致性要求不高。

- rdb文件在内存中的加载速度比aof快得多。

**劣势**

- 并不是实时备份，总会有某一刻没有备份的数据，所以在redis以外down的时候，就会丢失从当前到最近一次快照期间的数据。

- 数据的全量同步，如果数据量太大会导致I/O严重。

- RDB依赖主进程的fork，在更大的数据集中，可能会导致服务请求的瞬间延迟，fork时内存中的数据会被克隆一份，大致2倍的膨胀性，需要考虑。

**修复dump.rdb文件**

极端情况下redis正在写入一个很大的数据后备份时down掉，可能会导致dump.rdb不完整，这时就需要修复dump.rdb文件了。

```shell
[root@localhost myredis]# redis-check-rdb /myredis/dumpfiles/dump6379.rdb
[offset 0] Checking RDB file /myredis/dumpfiles/dump6379.rdb
[offset 26] AUX FIELD redis-ver = '7.0.0'
[offset 40] AUX FIELD redis-bits = '64'
[offset 52] AUX FIELD ctime = '1684587365'
[offset 67] AUX FIELD used-mem = '1080320'
[offset 79] AUX FIELD aof-base = '0'
[offset 81] Selecting DB ID 0
[offset 165] Checksum OK
[offset 165] \o/ RDB looks OK! \o/
[info] 10 keys read
[info] 0 expires
[info] 0 already expired
```

**触发RDB快照的场景**

- 配置文件的快照配置条件达成时会自动触发

- 执行save/bgsave时会手动触发

- 执行flushdb/flushall命令时会触发，将数据变为空保持一致性

- 执行shutdown时（且没有开启AOF持久化）会最后一次触发将没有备份的数据写入rdb文件。

- 主从复制时，主节点自动触发。

**禁止快照**

调整配置，`save ""`

**更多配置**

```shell
# 默认yes
# 如果配置成no，表示不在乎数据不一致或者有其他的手段发现和控制这种不一致
# 那么在快照写入失败时，也能确保redis继续接受新的写请求
stop-writes-on-bgsave-error yes
# 默认yes
# 对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。
# 如果不想消耗CPU来进行压缩的话，可以设置为关闭此功能
rdbcompression yes
# 默认yes
# 在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗
# 如果希望获取到最大的性能提升，可以关闭此功能
rdbchecksum yes
# 在没有持久性的情况下删除复制中使用的RDB文件启用。默认情况下no，此选项是禁用的。
rdb-del-sync-files no
```

**注意**

- 不可以把备份文件dump.rdb和生产redis服务器放到同一台机器，必须分开存储，以防生产机物理顺怀后备份文件也挂了。


