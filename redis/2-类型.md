# Key

redis是key-value数据库，类型是针对value的，key都是字符串。key是区分大小写，而命令不区分大小写。

**key的常用操作**

| 操作                   | 含义                             | 返回值                       |
| -------------------- | ------------------------------ | ------------------------- |
| keys *               | 查看当前库所有的key，谨慎使用               | 为空返回(empty array)         |
| exists key           | 判断key是否存在                      | 存在返回1，反之0                 |
| type key1            | 判断key是什么类型                     | string、list等等，key不存在为none |
| del key1             | 删除指定的key                       | 成功返回1，失败返回0               |
| unlink key1          | 非阻塞删除，仅从keyspace中删除，真正的删除会异步进行 | 成功返回1，失败返回0               |
| ttl key1             | 查看还有多少秒过期                      | -1表示用不过期、-2表示已过期或被删除      |
| expire key1 秒数       | 为指定的key设置秒过期时间                 | 成功返回1，失败返回0               |
| pexpire key1 毫秒      | 为指定的key设置毫秒过期时间                | 成功返回1，失败返回0               |
| expireat key1 时间戳    | 为指定的key设置秒时间戳过期时间              | 成功返回1，失败返回0               |
| pexpireat key1 毫秒时间戳 | 为指定的key设置毫秒时间戳过期时间             | 成功返回1，失败返回0               |
| move key dbindex     | 将key移动到指定的数据库db中               | 成功返回1，失败返回0               |
| select dbindex       | 切换数据库                          | 成功返回1，失败返回0               |
| dbsize               | 查看当前数据库key的数量                  | key的数量                    |
| flushdb              | 清空当前库                          |                           |
| flushall             | 清空全部库                          |                           |

# Help帮助命令

redis内置的帮助文档命令

```shell
# help @类型
127.0.0.1:6379> help @string
```

# String

string是redis最基本的类型，一个key对应一个value。String类型是二进制安全的，意思是redis的string类型可以包含任意数据。字符串value最多可以是512M。

**命令场景**

- 最常用的

```shell
# 最简单的设置和获取，永不过期
127.0.0.1:6379> set key helloworld
OK
127.0.0.1:6379> get key
"helloworld"

# set时设置过期时间，是一个原子操作
127.0.0.1:6379> set key1 helloworld1 ex 60
OK
127.0.0.1:6379> ttl key1
(integer) 57
# set时保持之前的过期时间
127.0.0.1:6379> set key1 helloworld1_update keepttl
OK
127.0.0.1:6379> ttl key1
```

SET的参数

```shell
SET key value [NX | XX] [GET] [EX seconds | PX milliseconds |
  EXAT unix-time-seconds | PXAT unix-time-milliseconds | KEEPTTL]

# NX 当key不存在时设置
# XX 当key已存在时设置
# GET 返回key原本的值，不存在时返回nil
127.0.0.1:6379> set key1 helloworld1_update GET
"helloworld1"
127.0.0.1:6379> get key1
"helloworld1_update"
# EX seconds 以秒为单位设置过期时间
# PX milliseconds 以毫秒为单位设置过期时间
# EXAT unix-time-seconds 以秒时间戳设置过期时间
# PXAT unix-time-milliseconds 以毫秒时间戳设置过期时间
# KEEPTTL 保持之前的过期时间，但对于已过期或不存在的key，设置后是永久
```

- 同时设置/获取多个

```shell
# mset key value [key value ...]
127.0.0.1:6379> mset key1 aa key2 bb key3 cc
OK
127.0.0.1:6379> mget key1 key2 key3
1) "aa"
2) "bb"
3) "cc"

# msetnx key value [key value ...] 当key不存在时才设置
127.0.0.1:6379> msetnx key1 xx key2 yy key3 zz
(integer) 0
127.0.0.1:6379> msetnx key4 xx key5 yy key6 zz
(integer) 1
# 如果部分key存在，所有的都不会成功
127.0.0.1:6379> msetnx key6 bb key7 kk
(integer) 0
```

- 设置/获取指定区间的值

```shell
# getrange key start end
127.0.0.1:6379> set key7 "This is a string"
OK
127.0.0.1:6379> get key7
"This is a string"
127.0.0.1:6379> getrange key7 0 3
"This"
127.0.0.1:6379> getrange key7 -3 -1
"ing"

# setrange key offset value
127.0.0.1:6379> setrange key7 10 string10
(integer) 18
127.0.0.1:6379> get key7
"This is a string10"
```

- 数值增减（必须是数字）

```shell
# 必须是数字且必须是整数
127.0.0.1:6379> get key7
"This is a string10"
127.0.0.1:6379> incr key7
(error) ERR value is not an integer or out of range
# 自增1
127.0.0.1:6379> set key8 0
OK
127.0.0.1:6379> incr key8
(integer) 1
127.0.0.1:6379> get key8
"1"
# 按指定数字自增
127.0.0.1:6379> incrby key8 2
(integer) 3
127.0.0.1:6379> incrby key8 2
(integer) 5
127.0.0.1:6379> incrby key8 2
(integer) 7
# 按指定小数自增
127.0.0.1:6379> incrbyfloat key9 1.2
"11.2"
# 自减1
127.0.0.1:6379> decr key8
(integer) 6
# 按指定数字自减
127.0.0.1:6379> decrby key8 3
(integer) 2
127.0.0.1:6379> decrby key8 3
(integer) -1
```

- 获取字符串长度，内容追加

```shell
127.0.0.1:6379> get key7
"This is a string10"
# 统计string的长度
127.0.0.1:6379> strlen key7
(integer) 18
# 追加内容
127.0.0.1:6379> append key7 " append string"
(integer) 32
127.0.0.1:6379> get key7
"This is a string10 append string"
```

- 分布式锁

当多个客户端竞争同一个资源时，根据redis的setnx先获取锁（原子）再获取资源。

```shell
# 加锁成功访问资源
127.0.0.1:6379> set lock pay ex 10 nx
OK
# 加锁失败等待
127.0.0.1:6379> set lock pay ex 10 nx
(nil)
# 加锁成功
127.0.0.1:6379> set lock pay ex 10 nx
OK
# setex:设置带过期时间的key，动态设置 等同于 set key value ex 10
# setnx:只有在 key 不存在时设置 key 的值 等同于 set key value nx
```

* getset

```shell
127.0.0.1:6379> getset key7 "reset string"
"This is a string10 append string"
127.0.0.1:6379> get key7
"reset string"
```

**运用场景**

- 抖音直播无限点赞，点一次加一次

```shell
127.0.0.1:6379> incr like
(integer) 1
127.0.0.1:6379> incr like
(integer) 2
```

# List

List是单key多value，是一个典型的双向链表结构，容量为$2$32-1个元素，大约40多亿，一般用于栈、队列、消息队列等场景。

从左、从右都可以插入数据，如果key不存在时则新创建一个链表；如果key存在则新增内容；如果值全部移除对应的key也就删除。

List是有序、可重复的。

**命令场景**

- lpush/rpush/lrange

```shell
# lpush 从左边push数据
127.0.0.1:6379> lpush list1 1 2 3 4
(integer) 4
127.0.0.1:6379> type list1
list
# lrange 遍历list，注意并没有rrange
127.0.0.1:6379> lrange list1 0 -1
1) "4"
2) "3"
3) "2"
4) "1"
# rpush 从右边push数据
127.0.0.1:6379> rpush list1 0 -1 -2 -3
(integer) 8
127.0.0.1:6379> lrange list1 0 -1
1) "4"
2) "3"
3) "2"
4) "1"
5) "0"
6) "-1"
7) "-2"
8) "-3"
```

- lpop/rpop

```shell
# lpop 从左边pop一个元素
127.0.0.1:6379> lpop list1
"4"
# 从左边pop2个元素
127.0.0.1:6379> lpop list1 2
1) "3"
2) "2"
# rpop 从右边pop一个元素
127.0.0.1:6379> rpop list1
"-3"
# 从右边pop2个元素
127.0.0.1:6379> rpop list1 2
1) "-2"
2) "-1"
```

- lindex

```shell
# lindex 按照索引下标获得元素
127.0.0.1:6379> lrange list1 0 -1
1) "1"
2) "0"
127.0.0.1:6379> lindex list1 1
"0"
```

- llen

```shell
# llen 获取list的元素个数
127.0.0.1:6379> llen list1
(integer) 2
```

- lrem key N V

```shell
127.0.0.1:6379> lrange list2 0 -1
1) "2"
2) "3"
3) "1"
4) "1"
5) "2"
6) "2"
7) "1"
8) "1"
# lrem 从左往右，删除N个等于V的值
127.0.0.1:6379> lrem list2 2 2
(integer) 2
127.0.0.1:6379> lrange list2 0 -1
1) "3"
2) "1"
3) "1"
4) "2"
5) "1"
6) "1"
```

- ltrim key startIndex endIndex

```shell
# 截取指定范围的值再赋值给key
127.0.0.1:6379> ltrim list2 0 3
OK
127.0.0.1:6379> lrange list2 0 -1
1) "3"
2) "1"
3) "1"
4) "2"
```

- rpoplpush

```shell
# rpoplpush 源list 目标list，从源list右边pop一个元素到目标list的左边
127.0.0.1:6379> lpush list3 1 1 1 1
(integer) 4
127.0.0.1:6379> rpush list4 2 2 2 2
(integer) 4
127.0.0.1:6379> rpoplpush list3 list4
"1"
127.0.0.1:6379> lrange list3 0 -1
1) "1"
2) "1"
3) "1"
127.0.0.1:6379> lrange list4 0 -1
1) "1"
2) "2"
3) "2"
4) "2"
5) "2"
```

- lset

```shell
# lset key index value 设置下标为index的值为value
127.0.0.1:6379> lset list4 2 "lset"
OK
127.0.0.1:6379> lrange list4 0 -1
1) "1"
2) "2"
3) "lset"
4) "2"
5) "2"
# 下标不存在的时候会报错
127.0.0.1:6379> lset list4 5 "index not exist"
(error) ERR index out of range
```

- linsert

```shell
# linsert key before/after 已有值 插入的新值
# 针对不重复的list可行
127.0.0.1:6379> linsert list4 before 2 "before"
(integer) 6
127.0.0.1:6379> lrange list4 0 -1
1) "1"
2) "before"
3) "2"
4) "lset"
5) "2"
6) "2"
```

**运用场景**

- 发布订阅

# Hash

K-V模式，但V是一个K-V。

**命令场景**

- hset/hget/hmset/hmget/hgetall/hdel

```shell
# hset key field value [field value ...]
127.0.0.1:6379> hset user01 id 1 name "zhangsan" age 12 score 88.3
(integer) 4
# hget key field 获取Hash的单个字段值
127.0.0.1:6379> hget user01 score
"88.3"
# hmget 获取hash的多个字段值
127.0.0.1:6379> hmget user01 id name age score
1) "1"
2) "zhangsan"
3) "12"
4) "88.3"
# hgetall 获取所有字段值
127.0.0.1:6379> hgetall user01
1) "id"
2) "1"
3) "name"
4) "zhangsan"
5) "age"
6) "12"
7) "score"
8) "88.3"
# 如果字段不存在则新增，如果存在则覆盖
127.0.0.1:6379> hset user01 remark "good"
(integer) 1
# hdel key field [field ...] 删除多个field
127.0.0.1:6379> hdel user01 remark
(integer) 1
```

- hlen

```shell
# hlen key 获取元素个数
127.0.0.1:6379> hlen user01
(integer) 5
```

- hkeys/hvals

```shell
# hkeys key 获取hash的所有字段
127.0.0.1:6379> hkeys user01
1) "id"
2) "name"
3) "age"
4) "score"
5) "remark"
# hvals key 获取hash的所有value
127.0.0.1:6379> hvals user01
1) "1"
2) "zhangsan"
3) "12"
4) "88.3"
5) "good+love1"
```

- hincrby/hincrbyfloat

```shell
# hincrby key field num 字段自增
127.0.0.1:6379> hincrby user01 age 2
(integer) 14
# hincrby key field float 字段自增小数
127.0.0.1:6379> hincrbyfloat user01 score 2
"90.3"
```

- hsetnx

```shell
# hsetnx key field value 当field不存在时设置成功返回1，否则失败返回0
127.0.0.1:6379> hsetnx user01 remark 1
(integer) 0
127.0.0.1:6379> hsetnx user01 remark1 3
(integer) 1
```

**运用场景**

- 添加购物车、增加商品数量、全选

# Set

Set类型是单key多value模式，且是无序的，且value不能重复。

如果key不存在时，sadd会创建key；如果添加一个已存在的值会失败；

**命令场景**

- sadd/smembers

```shell
# sadd key value [value ...] 往集合里面添加元素
127.0.0.1:6379> sadd set2 2 1 2 3 4 5 6 1 7
(integer) 7
# smembers key 遍历集合中所有元素
127.0.0.1:6379> smembers set2
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"
7) "7"
# 3已经在set2中了，添加失败
127.0.0.1:6379> sadd set2 3
(integer) 0
127.0.0.1:6379> sadd set2 8
(integer) 1
```

- sismember key member

```shell
# sismember key member 判断元素是否存在集合中
127.0.0.1:6379> sismember set2 8
(integer) 1
127.0.0.1:6379> sismember set2 9
(integer) 0
```

- srem key member [member ...]

```shell
# srem key member [member ...] 从集合中删除多个元素
127.0.0.1:6379> srem set2 8
(integer) 1
127.0.0.1:6379> smembers set2
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"
7) "7"
```

- scard

```shell
# scard key 获取集合中的元素个数
127.0.0.1:6379> scard set2
(integer) 7
```

- srandmember key [number]

```shell
# srandmember key [number] 从集合中随机获取几个元素，但不会从集合中删除
# 随机获取一个元素
127.0.0.1:6379> srandmember set2
"3"
127.0.0.1:6379> srandmember set2
"2"
# 随机获取3个元素
127.0.0.1:6379> srandmember set2 3
1) "7"
2) "6"
3) "3"
```

- spop key [member]

```shell
# spop key [member] 随机pop多个元素
# 随机pop1个元素
127.0.0.1:6379> spop set2
"2"
127.0.0.1:6379> smembers set2
1) "1"
2) "3"
3) "4"
4) "5"
5) "6"
6) "7"
# 随机pop2个元素
127.0.0.1:6379> spop set2 2
1) "1"
2) "4"
127.0.0.1:6379> smembers set2
1) "3"
2) "5"
3) "6"
4) "7"
```

- smove key1 key2 key1中存在的元素

```shell
# smove key1 key2 key1中存在的元素 从key1中奖已存在的元素移动到key2
# 注意如果移动的元素也存在key2中，key1会移除该元素，但key2不会重复
27.0.0.1:6379> smembers set1
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"
7) "7"
127.0.0.1:6379> smembers set2
1) "3"
2) "5"
3) "6"
4) "7"
127.0.0.1:6379> smove set1 set2 2
(integer) 1
127.0.0.1:6379> smembers set1
1) "1"
2) "3"
3) "4"
4) "5"
5) "6"
6) "7"
127.0.0.1:6379> smembers set2
1) "2"
2) "3"
3) "5"
4) "6"
5) "7"
127.0.0.1:6379> smove set1 set2 5
(integer) 1
127.0.0.1:6379> smembers set1
1) "1"
2) "3"
3) "4"
4) "6"
5) "7"
127.0.0.1:6379> smembers set2
1) "2"
2) "3"
3) "5"
4) "6"
5) "7"
```

- 集合运算
  
  - 求差集
  
  ```shell
  # sdiff key [key ...] 会返回属于A但不属于B的所有元素
  127.0.0.1:6379> sadd set1 1 2 3 4
  (integer) 4
  127.0.0.1:6379> sadd set2 3 4 5 6
  (integer) 4
  127.0.0.1:6379> sdiff set1 set2
  1) "1"
  2) "2"
  ```
  
  - 求并集
  
  ```shell
  # union key [key ...] 会返回A和B的所有元素集合
  127.0.0.1:6379> sunion set1 set2
  1) "1"
  2) "2"
  3) "3"
  4) "4"
  5) "5"
  6) "6"
  ```
  
  - 求交集
  
  ```shell
  # sinter key [key ...] 会返回A和B都有的元素集合
  127.0.0.1:6379> sinter set1 set2
  1) "3"
  2) "4"
  
  # sintercard numberkeys key [key ...] [limit] 会返回A和B交集的元素个数
  # numberkeys 是key的数量
  # limit 是限制的数量
  127.0.0.1:6379> sintercard 2 set1 set2 limit 1
  (integer) 1
  127.0.0.1:6379> sintercard 2 set1 set2
  (integer) 2
  ```

**运用场景**

- 抽奖小程序

```shell
# 1. 用户点击参与抽奖，往集合中添加用户ID
127.0.0.1:6379> sadd lotteryA 1
(integer) 1
127.0.0.1:6379> sadd lotteryA 2
(integer) 1
127.0.0.1:6379> sadd lotteryA 3
(integer) 1
127.0.0.1:6379> sadd lotteryA 4
(integer) 1
# 2. 显示有多少人参与了抽奖
127.0.0.1:6379> scard lotteryA
(integer) 4
# 3. 抽出中奖用户，使用srandmember或spop随机生成
127.0.0.1:6379> srandmember lotteryA 2
1) "4"
2) "3"
```

- 朋友圈点赞查看同赞好友

```shell
# 1. 新增点赞
127.0.0.1:6379> sadd friendCircle:1 1
(integer) 1
127.0.0.1:6379> sadd friendCircle:1 2
(integer) 1
127.0.0.1:6379> sadd friendCircle:1 3
(integer) 1
127.0.0.1:6379> sadd friendCircle:1 4
(integer) 1
# 2. 取消点赞
127.0.0.1:6379> srem friendCircle:1 4
(integer) 1
# 3. 展示所有点过赞的用户
127.0.0.1:6379> smembers friendCircle:1
1) "1"
2) "2"
3) "3"
# 4. 点赞数
127.0.0.1:6379> scard friendCircle:1
(integer) 3
# 5. 展示用户1的点赞的朋友
127.0.0.1:6379> sadd friend:1 2 3
(integer) 2
127.0.0.1:6379> sinter friend:1 friendCircle:1
1) "2"
2) "3"
```

- 脉脉可能认识的人，和朋友圈点赞的朋友类似
