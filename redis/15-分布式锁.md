# 单机锁

单机锁是指在单个机器或进程内使用的锁机制，用于保护共享资源访问，它适用于单机环境中的并发控制和数据一致性需求。

**问题**

对于单机环境没什么问题，但是一旦遇到服务器扩容或分布式系统就无法保证互斥效果，因为单机锁只在单台机器上有效。

**go语言的单机锁**

```go
func main() {
    var lock sync.Mutex
    i := 0
    // 加锁
    lock.Lock()
    // 释放锁
    defer lock.Unlock()
    i++
    fmt.Println(i)
}
```

# 引入分布式锁

为了解决分布式系统中的互斥访问的问题，用于保护共享资源或临界区的访问，在多个进程或多台机器之间，确保只有一个进程能够获取到锁，并在完成后释放锁，以保证一致性和并发控制。实现分布式锁需要选择合适的存储介质，比如redis、zookeeper等。

**写好一个分布式锁的要求**

- 独占性
  
  - OnlyOne，任何时刻只能有且仅有一个线程持有

- 高可用
  
  - Redis集群下，不能因为某一个节点挂了而出现获取锁和释放锁失败
  
  - 高并发请求下，性能不能减弱

- 防死锁
  
  - 杜绝死锁，必须有超时控制机制或撤销操作，有兜底跳出方案

- 不乱抢
  
  - 不能unlock别人的锁，只能自己加锁自己解锁

- 重入性
  
  - 同一个节点的同一个线程如果获取锁后，它也要可以再次获取这个锁。

# 手写分布式锁

以扣减库存为例，逐步迭代，本例使用golang。

**第一版本：单机锁**

```go
var rdb5 *redis.Client
var lock sync.Mutex

func init() {
	rdb5 = redis.NewClient(&redis.Options{
		Addr:     "localhost:6379",
		Password: "123", // no password set
		DB:       0,     // use default DB
	})
}

func main() {
	ctx := context.Background()
	key := "inventory:001"
	sale(ctx, key)
}

// sale 售卖商品扣减库存主逻辑
func sale(ctx context.Context, key string) {
	lock.Lock()
	defer lock.Unlock()
	inventoryNum, _ := strconv.Atoi(rdb5.Get(ctx, key).Val())
	if inventoryNum > 0 {
		inventoryNum--
		rdb5.Set(ctx, key, inventoryNum, -1)
		fmt.Printf("成功卖出一个商品，剩余库存为：%d\n", inventoryNum)
	} else {
		fmt.Println("商品已售罄")
	}
}
```

运行程序：

```shell
# 预先向redis设置库存数据
127.0.0.1:6379> set inventory:001 100
OK

# 运行程序
go run inventory.go
成功卖出一个商品，剩余库存为：99
go run inventory.go
成功卖出一个商品，剩余库存为：98
```
