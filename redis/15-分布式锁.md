# 单机锁

单机锁是指在单个机器或进程内使用的锁机制，用于保护共享资源访问，它适用于单机环境中的并发控制和数据一致性需求。

**问题**

对于单机环境没什么问题，但是一旦遇到服务器扩容或分布式系统就无法保证互斥效果，因为单机锁只在单台机器上有效。

**go语言的单机锁**

```go
func main() {
    var lock sync.Mutex
    i := 0
    // 加锁
    lock.Lock()
    // 释放锁
    defer lock.Unlock()
    i++
    fmt.Println(i)
}
```

# 引入分布式锁

为了解决分布式系统中的互斥访问的问题，用于保护共享资源或临界区的访问，在多个进程或多台机器之间，确保只有一个进程能够获取到锁，并在完成后释放锁，以保证一致性和并发控制。实现分布式锁需要选择合适的存储介质，比如redis、zookeeper等。

**写好一个分布式锁的要求**

- 独占性
  
  - OnlyOne，任何时刻只能有且仅有一个线程持有

- 高可用
  
  - Redis集群下，不能因为某一个节点挂了而出现获取锁和释放锁失败
  
  - 高并发请求下，性能不能减弱

- 防死锁
  
  - 杜绝死锁，必须有超时控制机制或撤销操作，有兜底跳出方案

- 不乱抢
  
  - 不能unlock别人的锁，只能自己加锁自己解锁

- 重入性
  
  - 同一个节点的同一个线程如果获取锁后，它也要可以再次获取这个锁。

# 手写分布式锁

以扣减库存为例，逐步迭代，本例使用golang。

**第一版本：单机锁**

```go
var rdb5 *redis.Client
var lock sync.Mutex

func init() {
    rdb5 = redis.NewClient(&redis.Options{
        Addr:     "localhost:6379",
        Password: "123", // no password set
        DB:       0,     // use default DB
    })
}

func main() {
    ctx := context.Background()
    key := "inventory:001"
    sale(ctx, key)
}

// sale 售卖商品扣减库存主逻辑
func sale(ctx context.Context, key string) {
    lock.Lock()
    defer lock.Unlock()
    inventoryNum, _ := strconv.Atoi(rdb5.Get(ctx, key).Val())
    if inventoryNum > 0 {
        inventoryNum--
        rdb5.Set(ctx, key, inventoryNum, -1)
        fmt.Printf("成功卖出一个商品，剩余库存为：%d\n", inventoryNum)
    } else {
        fmt.Println("商品已售罄")
    }
}
```

运行程序：

```shell
# 预先向redis设置库存数据
127.0.0.1:6379> set inventory:001 100
OK

# 运行程序
go run inventory.go
成功卖出一个商品，剩余库存为：99
go run inventory.go
成功卖出一个商品，剩余库存为：98
```

问题：对于单机肯定没有问题，但分布式系统必定出错。

**第二版：使用nginx分布式微服务架构**

- 改造成可以访问的http请求

```go
var rdb5 *redis.Client
var lock sync.Mutex

var port string

func init() {
    rdb5 = redis.NewClient(&redis.Options{
        Addr:     "192.168.10.33:6379",
        Password: "123456", // no password set
        DB:       0,        // use default DB
    })
    flag.StringVar(&port, "port", "8080", "启动端口")
    flag.Parse()
}

func main() {
    http.HandleFunc("/sale", saleHandler)
    http.ListenAndServe(":"+port, nil)
}

func saleHandler(w http.ResponseWriter, r *http.Request) {
    ctx := context.Background()
    key := "inventory:001"
    message := sale(ctx, key)
    fmt.Fprintf(w, "端口号："+port+"，"+message)
}

func sale(ctx context.Context, key string) string {
    lock.Lock()
    defer lock.Unlock()
    inventoryNum, _ := strconv.Atoi(rdb5.Get(ctx, key).Val())
    if inventoryNum > 0 {
        inventoryNum = inventoryNum - 1
        rdb5.Set(ctx, key, inventoryNum, 0)
        return fmt.Sprintf("成功卖出一个商品，剩余库存为：%d\n", inventoryNum)
    } else {
        return fmt.Sprintln("商品已售罄")
    }
}
```

- 启动微服务

```shell
go build -o inventory inventory.go
# 先启动8080和8081两个微服务
./inventory -port 8080
./inventory -port 8081
```

- 配置nginx负载均衡

```nginx
upstream inventoryUpstream {
    server localhost:8080 weight=1;
    server localhost:8081 weight=1;
}

server {
    listen  80;
    server_name inventory.com;

    location / {
            proxy_pass http://inventoryUpstream;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
    }
}
```

- 重启nginx

```shell
./nginx -s reload
```

- 通过并发工具（Apache jmeter）测试

![jemeter-1](./images/jemeter-test1.png)

![jemeter-test2](./images/jemeter-test2.png)

![jemeter-test3](./images/jemeter-test3.png)

![jemeter-test4](./images/jemeter-test4.png)

![jemeter-test5](./images/jemeter-test5.png)

- 查看redis中的剩余库存

```shell
127.0.0.1:6379> get inventory:001
"34"
```

问题：进一步验证单机锁对于分布式系统无效，需要采用分布式锁，引入redis。

**第三版：使用Redis实现分布式锁**

引入分布式锁：

```go
func sale(ctx context.Context, key string) string {
	lockKey := "inventoryRedisLock"
	// 通过uuid+现成ID
	uuidValue := uuid.New().String() + ":" + strconv.FormatInt(goid.Get(), 10)
	// 没有抢占到锁会一直循环获取
	for !rdb5.SetNX(ctx, lockKey, uuidValue, 0).Val() {
		// 暂停20毫秒继续获取锁
		time.Sleep(20 * time.Millisecond)
	}
	// 使用完成之后删除锁
	defer rdb5.Del(ctx, lockKey)

	inventoryNum, _ := strconv.Atoi(rdb5.Get(ctx, key).Val())
	if inventoryNum > 0 {
		inventoryNum = inventoryNum - 1
		rdb5.Set(ctx, key, inventoryNum, 0)
		return fmt.Sprintf("成功卖出一个商品，剩余库存为：%d\n", inventoryNum)
	} else {
		return fmt.Sprintln("商品已售罄")
	}
}
```

- 压测结果：未超卖

![jemeter-test6](./images/jemeter-test6.png)

问题：设置锁没有过期时间，一旦一台程序挂了且没有释放锁，其他程序就无法抢占锁

**第四版：改进锁过期时间**

```go
func sale(ctx context.Context, key string) string {
	lockKey := "inventoryRedisLock"
	// 通过uuid+现成ID
	uuidValue := uuid.New().String() + ":" + strconv.FormatInt(goid.Get(), 10)
	// 没有抢占到锁会一直循环获取，这里新增了锁的过期时间，避免程序挂了导致其他正常的程序获取不到锁的问题，这个时间需要根据实际业务估算，且不能使用一条语句保证原子性
	// 查看SexNX源码里层是原子性的。
	for !rdb5.SetNX(ctx, lockKey, uuidValue, 20*time.Second).Val() {
		// 暂停20毫秒继续获取锁
		time.Sleep(20 * time.Millisecond)
	}
	// 使用完成之后删除锁
	defer rdb5.Del(ctx, lockKey)

	inventoryNum, _ := strconv.Atoi(rdb5.Get(ctx, key).Val())
	if inventoryNum > 0 {
		inventoryNum = inventoryNum - 1
		rdb5.Set(ctx, key, inventoryNum, 0)
		return fmt.Sprintf("成功卖出一个商品，剩余库存为：%d\n", inventoryNum)
	} else {
		return fmt.Sprintln("商品已售罄")
	}
}
```

- 压测未超卖

问题：如果处理时间超过了预设的过期时间，会导致误删其他线程的锁。比如A线程的处理时间超过了20秒，20秒后锁过期了，B线程获取到锁进入，此时A处理完成后删除了B的锁，B处理后发现自己的锁被删除。

**第五版：改进误删锁问题**

```go
func sale(ctx context.Context, key string) string {
	lockKey := "inventoryRedisLock"
	// 通过uuid+现成ID
	uuidValue := uuid.New().String() + ":" + strconv.FormatInt(goid.Get(), 10)
	// 没有抢占到锁会一直循环获取，这里新增了锁的过期时间，避免程序挂了导致其他正常的程序获取不到锁的问题，这个时间需要根据实际业务估算，且不能使用一条语句保证原子性
	// 查看SexNX源码里层是原子性的。
	for !rdb5.SetNX(ctx, lockKey, uuidValue, 20*time.Second).Val() {
		// 暂停20毫秒继续获取锁
		time.Sleep(20 * time.Millisecond)
	}
	// 使用完成之后删除锁，且要判断误删锁
	defer func() {
		if rdb5.Get(ctx, lockKey).Val() == uuidValue {
			rdb5.Del(ctx, lockKey)
		}
	}()

	inventoryNum, _ := strconv.Atoi(rdb5.Get(ctx, key).Val())
	if inventoryNum > 0 {
		inventoryNum = inventoryNum - 1
		rdb5.Set(ctx, key, inventoryNum, 0)
		return fmt.Sprintf("成功卖出一个商品，剩余库存为：%d\n", inventoryNum)
	} else {
		return fmt.Sprintln("商品已售罄")
	}
}
```

- 压测数据正常

问题：删除锁是两步操作，并不是原子操作，依然可能存在风险。

**第六版：保证保证性**

- Redis使用Lua脚本

```shell
127.0.0.1:6379> eval "return 'hello lua'" 0
"hello lua"

127.0.0.1:6379> eval "redis.call('set', 'k1', 'v1') return redis.call('get', 'k1')" 0
"v1"

127.0.0.1:6379> eval "return redis.call('mset', KEYS[1], ARGV[1], KEYS[2], ARGV[2])" 2 k1 k2 11 12
OK
127.0.0.1:6379> get k1
"11"
127.0.0.1:6379> get k2
"12"
```

- 本例需要的Lua脚本

```lua
if redis.call('get', KEYS[1] == ARGV[1]) then
    return redis.call('del', KEYS[1])
else
    return 0
end
```

- Redis执行Lua

```shell
# 当inventoryRedisLock的值为112121212时删除
127.0.0.1:6379> eval "if redis.call('get', KEYS[1] == ARGV[1]) then     return redis.call('del', KEYS[1]) else     return 0 end" 1 inventoryRedisLock 112121212
(integer) 0
```

- 代码实现

```go
func sale(ctx context.Context, key string) string {
	lockKey := "inventoryRedisLock"
	// 通过uuid+现成ID
	uuidValue := uuid.New().String() + ":" + strconv.FormatInt(goid.Get(), 10)
	// 没有抢占到锁会一直循环获取，这里新增了锁的过期时间，避免程序挂了导致其他正常的程序获取不到锁的问题，这个时间需要根据实际业务估算，且不能使用一条语句保证原子性
	// 查看SexNX源码里层是原子性的。
	for !rdb5.SetNX(ctx, lockKey, uuidValue, 20*time.Second).Val() {
		// 暂停20毫秒继续获取锁
		time.Sleep(20 * time.Millisecond)
	}
	// 使用完成之后删除锁，且要判断误删锁
	defer func() {
		// 通过Lua脚本保证原子性
		luaScript := "if redis.call('get', KEYS[1] == ARGV[1]) then " +
			"return redis.call('del', KEYS[1]) " +
			"else " +
			"return 0 " +
			"end"
		rdb5.Eval(ctx, luaScript, []string{lockKey}, uuidValue)
	}()

	inventoryNum, _ := strconv.Atoi(rdb5.Get(ctx, key).Val())
	if inventoryNum > 0 {
		inventoryNum = inventoryNum - 1
		rdb5.Set(ctx, key, inventoryNum, 0)
		return fmt.Sprintf("成功卖出一个商品，剩余库存为：%d\n", inventoryNum)
	} else {
		return fmt.Sprintln("商品已售罄")
	}
}
```


