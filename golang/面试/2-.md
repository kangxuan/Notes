# nil切片和空切片的区别？

```go
var s1 []int // nil切片
s2 := make([]int, 0) // 空切片
s4 := make([]int, 0)
fmt.Printf("s1 pointer:%+v, s2 pointer:%+v, s4 pointer:%+v, \n", *(*reflect.SliceHeader)(unsafe.Pointer(&s1)), *(*reflect.SliceHeader)(unsafe.Pointer(&s2)), *(*reflect.SliceHeader)(unsafe.Pointer(&s4)))
fmt.Printf("%v\n", (*(*reflect.SliceHeader)(unsafe.Pointer(&s1))).Data == (*(*reflect.SliceHeader)(unsafe.Pointer(&s2))).Data)
fmt.Printf("%v\n", (*(*reflect.SliceHeader)(unsafe.Pointer(&s4))).Data == (*(*reflect.SliceHeader)(unsafe.Pointer(&s2))).Data)
```

以上代码输出：

```log
s1 pointer:{Data:0 Len:0 Cap:0}, s2 pointer:{Data:824634207952 Len:0 Cap:0}, s4 pointer:{Data:824634207952 Len:0 Cap:0}, 
false
true
```

可以发现nil切片指向数组的指针是不存在的，而空切片指向数组的指针是固定的，且一个进程中是相同的。

# 字符串转成[]byte，会发生内存拷贝吗？

字符串转换成`[]byte`，会发生内存拷贝，严格来说，只要发生类型且强制转换都会发生内存拷贝，如何规避？

```go
func main() {
	s1 := "abcdefg"
	// 强制转换都会发生内存拷贝
	s2 := []byte(s1)
	fmt.Println(s2)
	// 规避发生内存拷贝
	// unsafe.Pointer(&s1)方法可以得到变量s1的地址
	// (*reflect.StringHeader)(unsafe.Pointer(&a))可以把字符串s1转成底层结构的形式
	ssh := *(*reflect.StringHeader)(unsafe.Pointer(&s1))
	// (*[]byte)(unsafe.Pointer(&ssh)) 可以把ssh底层结构体转成byte的切片的指针
	s3 := *(*[]byte)(unsafe.Pointer(&ssh))
	fmt.Printf("%v", s3)
}
```

# 字符串翻转

需要考虑到字符串中包含中文，需要将string转换成rune。

```go
func main() {
	s1 := "你好hello123"
	s2 := reverse([]rune(s1))
	fmt.Println(string(s2))
}

// reverse 字符串翻转
func reverse(s []rune) []rune {
	// 转换
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
	return s
}
```

# 拷贝大切片比拷贝小切片代价大吗？

因为切片的底层是三个字段（一个指向数组的指针，两个int，长度和容量），拷贝切片无非就是将这三个字段拷贝一下，所以拷贝大切片和小切片代价一样。

```go
type slice struct {
    data uintptr // 一个指向数组的指针
    len int // 长度
    cap int // 容量
}
```

# JSON包变量不加tag会怎样？

1. 如果是非导出字段，无论是否加tag都取不到。

2. 如果是导出字段，不加tag，json字段名和结构体的字段一样；如果增加了tag，json字段和tag定义的字段名。

3. 


