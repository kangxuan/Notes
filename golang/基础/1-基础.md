# 语言特性

* 特性
1. 没有类和继承的概念，类型之间没有层级之说。
2. 通过接口实现多态性。
3. go使用静态类型，所以他是类型安全的语言。
4. go是一门强类型语言
   1. <mark>不允许隐式的类型转换(PHP可以进行隐式转换，所以刚上手的时候有些不习惯)</mark>
   2. 让所有的东西都是显式的
   3. 也有一些动态语言的特性（通过关键字var）
5. 支持交叉编译
   1. ==类似说可以在运行Linux系统的计算机上开发运行Windows下运行的应用程序==
   2. 因为go是完全支持UTF-8的编程语言，不仅体现在处理使用UTF-8编码的字符串，就连他的源文件格式都是使用了UTF-8。
* 用途（适合做什么）
1. ==用于实现高性能、海量并发的程序==
   1. Go被设计成一门应用于搭载Web服务器，存储集群或类似用途的巨型中央服务器的系统编程语言，在处理高性能分布式系统领域会比其他语言更高效。
   2. 提供了海量并行的支持
   3. 适合游戏服务器端开发
2. 一样可以用来实现一般目标
   1. 文本处理、前端展现、脚本开发等等。
   2. web开发
* 不支持的特性
1. 不支持函数重载和操作符重载
2. 不支持隐式转换
3. 不支持类和类型的继承
4. 不支持变体类型
5. 不支持动态加载代码
6. 不支持动态链接库
7. 不支持异常机制（==通过recover()和panic()来替代==）
8. 不支持静态变量

# 运行环境

* 编译器
1. Go原生编译器`gc`
   1. 编译速度比gccgo更快
   2. 但编译后的程序不能使用gcc链接
2. 非原生编译器`gccgo`
   1. 编译速度比gcc较慢
   2. 但产生的本地代码运行要稍微快一点
   3. 同时也提供了一些与C语言之间的互操作性

==两种编译器都适用于`Linux`、`FreeBSD`、`Mac OS X（drawin）`==

* 文件拓展名与包
1. go源文件的拓展名是 `.go`。

2. 文件夹名和文件名永远不要包含空格，而应该使用下划线或其他一般符号代替。
* 操作系统环境变量

环境变量需要在安装go之前设置好，不同操作系统的环境变量文件不同。

以mac os为例，`vim ~/.bash_profile`，然后`source .bash_profile`让其生效。

```
# Go的安装位置，一般在$HOME/go，也可以安装到其他位置
export GOROOT=/usr/local/go
# Go的项目位置
export GOPATH=/Users/kx/workspace/go
# Go的编译器和链接器安装位置，默认是$GOPATH/bin
export GOBIN=$GOPATH/bin
# Go为了确保相关文件在文件系统的任何地方都能被调用
export PATH=$PATH:$GOBIN
```

* 环境变量配置
  
  ```
  # 查看环境变量配置
  go env
  # 写入环境变量配置
  go env -w <NAME>=<VALUES>
  ```

* 配置项说明

```
# Go的安装位置，一般在$HOME/go，也可以安装到其他位置
GOROOT=/usr/local/go
# Go的项目位置
GOPATH=/Users/kx/workspace/go
# Go的编译器和链接器安装位置，默认是$GOPATH/bin
GOBIN=$GOPATH/bin
# 目标机器的操作系统（drawin、linux、FreeBSD、windows）
GOOS="darwin"
# 本地机器的处理器架构（386、amd64、arm）
GOHOSTARCH="amd64"
# 本地机器的操作系统（drawin、linux、FreeBSD、windows）
GOHOSTOS="darwin"
# 专门针对基于 arm 架构的处理器（5、6）
GOARM=6
# 用于设置应用程序可使用的处理器个数与核数
GOMAXPROCS
# GO111MODULE有3个值，off，on，auto（默认）
# off - go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。
# on - go命令行会使用modules，而一点也不会去GOPATH目录下查找
# auto - go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形：1. 当前目录在GOPATH/src之外且该目录包含go.mod文件；2.当前文件在包含go.mod文件的目录下面。详细请参考：https://zhuanlan.zhihu.com/p/374372749
GO111MODULE=auto
```

* 安装目录清单

```
├── AUTHORS
├── CONTRIBUTING.md
├── CONTRIBUTORS
├── LICENSE
├── PATENTS
├── README.md
├── SECURITY.md
├── VERSION
├── api # 用于存放依照 Go 版本顺序的 API 增量列表文件。这里所说的 API 包含公开的变量、常量、函数等。这些 API 增量列表文件用于 Go 语言 API 检查
├── bin # 包含可执行文件，比如go、gofmt、godoc
├── doc # 包含文档模板
├── favicon.ico
├── lib # 包含示例程序，代码工具或本地文档
├── misc # 包含与支持 Go 编辑器有关的配置文件以及 cgo 的示例
├── pkg # 用于存放安装Go标准库后的所有归档文件（以.a结尾的文件）。注意，你会发现其中有名称为linux_amd64的文件夹，我们称为平台相关目录。这类文件夹的名称由对应的操作系统和计算架构的名称组合而成。通过go install命令，Go程序会被编译成平台相关的归档文件存放到其中
├── robots.txt
├── src # 包含源代码构建脚本和标准库的包的完整源代码（Go 是一门开源语言）
│   ├── cmd # 包含 Go 和 C 的编译器和命令行脚本
│   ├── runtime # 负责管理内存分配、垃圾回收、栈处理、goroutine、channel、slice、map、reflection（反射）
└── test # 存放用来测试和验证Go本身的所有相关文件
```

# 常用命令

* go mod

为项目生成mod文件（包管理）

```
go mod init go-example
```

为什么需要mod文件?

1. 下载第三方包时需要mod文件
   
   ```
   # 使用go get下载第三方包会提示未找到.mod文件
   go get go.uber.org/zap
   ```

# 错误提示

go: go.mod file not found in current directory or any parent directory.
...

```
下载 go.mod 文件中指明的所有依赖
```

go mod download

```
查漏补缺，整理现有的依赖
```

go mod tidy

```
查看现有的依赖结构
```

go mod graph

```
编辑 go.mod 文件
```

go mod edit

```
校验一个模块是否被篡改过
```

go mod verify

```
- go get

安装远程包

-v    显示操作流程的日志及信息，方便检查错误

-u    下载丢失的包，但不会更新已经存在的包

-d    只下载，不安装

-insecure    允许使用不安全的 HTTP 方式进行下载操作
```

// 国内设置go代理
go env -w GO111MODULE=on
go env -w GOPROXY=https://gaproxy.cn,direct // 这里用七牛云代理

go get github.com/gorilla/websocket

// 因为开启了环境变量GO111MODULE=on，会将go get的文件下载到GOPATH/pkg/mod里。将里面的文件复制到GOPATH/src即可。还是基础不扎实的锅。。。

// 在goland有.mod文件前提下，用go get -u后发现src/下没有文件
// 排查思路：要先在src/下先创建对应包的根目录或父级目录

```
拉取特定版本
```

# @后是版本号

go get github.com/beego/beego@v1.0.1

# 拉去最新的版本

go get golang.org/x/text@latest

```
拉取特定分支
```

# 请不要遗漏-u选项，否则go get可能使用本地已经缓存的代码，而未能执行更新。

go get -u github.com/beego/beego/v2@master

```
- go run

直接运行程序
```

go run xxx.go

```
- go build

测试编译，检查是否有编译错误，编译后会生成可执行文件。
```

go build xxx.go

```
- go fmt
```

# 只是输出格式化后的代码

gofmt xxx.go

# 格式化xxx.go并写入

gofmt -w xxx.go

# 格式化所有go文件并写入

gofmt -w *.go

# 格式化目录，并会返回每个文件的一些错误

gofmt -w learn

# 替换代码，会将go文件中的sum替换成a

gofmt -r 'sum -> a' -w learn/xxx.go

```
- go install
```

# 编译包文件并安装整个程序，编译的程序会在$GOROOT/bin下生成可执行文件以及将包放在$GOROOT/pkg下

go install ...

```
- go test
```

# 运行测试文件，运行以test结尾的go文件

go test xxx_test.go

```
# 实战问题

* goland `run` 报错`package ... is not in GOROOT`

* `go get -u` 下载包后无法被调用
1. 解决一
   需要启用Go模块集成，goland -> Settings -> Go -> Go Modules -> Enable Go modules integration(勾选上)
```
