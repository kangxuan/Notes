# 数组

数组是指一系列同一类型数据的集合，是由一个固定长度的特定类型元素组成的有序序列。

#### 概念拆分

- 不允许混合不同类型的值，比如不能同时包含字符串和整数。

- 数组由数组长度和数组类型组成，所以`[5]int`和`[10]int`是属于不同类型的。

- 数组长度必须是一个非负整数（确定数），可以由0个或多个元素组成。即在编译时能够知道是多少，因为编译时就要分配内存。

- 数组底层是一个连续的内存块，因而访问数组元素速度非常快。

- 数组长度最大为 2GB。

#### 注意点

- 大数组作为参数传递给函数，会消耗大量的内存（因为会值拷贝），一般都是传递数组指针或使用数组的切片。

#### 数组的定义

```go
// 数组定义
// 1.不初始化会默认0值
var a [3]int
fmt.Printf("值：%v---类型：%T\n", a, a) // [0 0 0] --- [3]int

// 2.编译器自行判断
var b = [...]int{1, 2, 3}
fmt.Printf("值：%v---类型：%T\n", b, b) // [1 2 3]  --- [3]int

a = b                              // 说明a和b的类型是相同的
fmt.Printf("值：%v---类型：%T\n", a, a) // [1 2 3] --- [3]int

// 3.编译器自行推断加下标
var c = [...]int{2: 3, 1: 2}
fmt.Printf("值：%v---类型：%T\n", c, c) // [0 2 3] --- [3]int

// 4. 混合2和3
var d = [...]int{1, 2, 4: 5, 6}
fmt.Printf("值：%v---类型：%T\n", d, d) // [1 2 0 0 5 6] --- [6]int
```

#### 数组的迭代

```go
var s = [4]int{1, 2, 3}
// for 迭代
for i:=0; i<len(s); i++ {
    fmt.Println(s[i])
}
// for range 迭代
for k, v := range s {
    fmt.Println(k, v)
}
```

#### 多维数组

```go
// ... 可以使用于最外层，里层不能用编译器进行自行判断
// 多维数组只有第一层可以使用...来让编译器推导数组长度。
group := [...][3]string{
    {"云", "贵", "川"},
    {"辽", "吉", "黑"},
    {"京", "津", "冀"},
}

// 迭代
for _, v1 := range group {
    for _, v2 := range v1 {
        fmt.Printf("%s\t", v2)
    }
    fmt.Println()
}
```

# 切片

切片是一个拥有相同类型元素的可变长度的序列，是对数组一个连续片段的引用，非常灵活，支持自动扩容。

#### 切片的结构

Slice是一个引用类型，由一个指向数组的指针，长度以及容量组成。

```go
type slice struct {
    data uintptr // 一个指向数组的指针
    len int // 长度
    cap int // 容量
}
```

#### 切片的定义

普通声明

```go
// var identifier [] type

// 1.只声明不初始化，默认初始化为nil: len=0 cap=0 clice= []
var s []int

// s[0] = 1 // 不能直接赋值，因为len=0，需要通过append


// 2.声明并初始化，声明一个len=3，cap=3的slice
var s = []int{1,2,3}
var s = []int{} // 不会初始化nil：len=0，cap=0 slice=[]

// 3.从数组截取slice
var a [10]int
var s []int
s = a[start:end]
```

make声明

```go
// make([]type, len, cap)

// 忽略cap，cap == len
s := make([]int, 10)

s := make([]int, 2, 10)
s[0] = 1
fmt.Printf("内容：%v---长度：%d---容量：%d\n", s, len(s), cap(s))

// 输出
//内容：[1 0]---长度：2---容量：10
```

#### 切片的遍历

```go
// 遍历切片
var langList = []string{"go", "php", "java", "c++"}
for i := 0; i < len(langList); i++ {
	fmt.Println(langList[i])
}

for _, v := range langList {
	fmt.Println(v)
}

// 只会输出下标 0 1 2 3
for k := range langList {
	fmt.Println(k)
}
```

#### 切片的长度和容量

切片拥有自己的长度和容量，我们可以通过使用内置的 len()函数求长度，使用内置的 cap()

函数求切片的容量。

切片的长度就是它所包含的元素个数。

切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。

```go
s := []int{1, 2, 3, 4, 5, 6}
fmt.Printf("内容：%v---长度：%d---容量：%d\n", s, len(s), cap(s))

c := s[:2]
fmt.Printf("内容：%v---长度：%d---容量：%d\n", c, len(c), cap(c))

d := s[1:3]
fmt.Printf("内容：%v---长度：%d---容量：%d\n", d, len(d), cap(d))

// 输出
//内容：[1 2 3 4 5 6]---长度：6---容量：6
//内容：[1 2]---长度：2---容量：6
//内容：[2 3]---长度：2---容量：5
```

#### reslice

去掉slice最后一个元素

```go
slice1 = slice1[:len(slice1)-1]
```

去掉slice第一个元素

```go
slice1 = slice1[1:len(slice1)]
```

去掉slice中间

```go
a2 := []int{1, 2, 3}
result2 := append(a2[:1], a2[2:]...)
```

将slice1追加到slice2

```go
result := append(slice2, slice1...)
```

复制slice1到slice2

```go
slice2 := make([]int, len(slice1))
copy(slice2, slice1)
```

为切片a拓展j个元素长度

```go
a2 = append(a2, make([]int, 10)...)
fmt.Println(a2)
```

在引 i 的位置插入元素 x

```go
a2 = append(a2[:5], append([]int{333}, a2[5:]...)...)
fmt.Println(a2)
```

在索引 i 的位置插入长度为 j 的新切片

```go
a2 = append(a2[:6], append(make([]int, 10), a2[6:]...)...)
fmt.Println(a2)
```

#### append

追加元素到切片，如果遇到容量不够会自动扩容。

```go
slice1 := []int{1, 2, 3}
slice1 = append(slice1, 4)
fmt.Println(slice1)
```

#### copy

将一个切片拷贝到另一个切片，Go 语言内建的 copy()函数可以迅速地将一个切片的数据复制到另外一个切片空间中，所以两个切片不是公用的同一个底层数组。

```go
// 切片是引用类型，a复制给b，都是用的同一个底层数组，所以修改b会影响
a := []int{1, 2, 3, 4}
b := a
fmt.Println(a)
fmt.Println(b)

b[0] = 100
fmt.Println(a)
fmt.Println(b)

// 输出
//[1 2 3 4]
//[1 2 3 4]
//[100 2 3 4]
//[100 2 3 4]

// 通过copy复制，会将拷贝到另外一个内存空间，所以修改d不会影响c
c := []int{1, 2, 3, 4, 5}
d := make([]int, 5)
copy(d, c)
d[0] = 100
fmt.Println(c)
fmt.Println(d)

// 输出
//[1 2 3 4 5]
//[100 2 3 4 5]

// 1.把短切片拷贝到长切片中
s1 := []int{1, 2}
s2 := []int{3, 4, 5, 6}
copy(s2, s1)
fmt.Println(s1) // s1:1,2
fmt.Println(s2) // s2:1,2,5,6

// 2.将长切片拷贝到短切片中
s1 := []int{1, 2}
s2 := []int{3, 4, 5, 6}
copy(s1, s2)
fmt.Println(s1) // s1:3,4
fmt.Println(s2) // s2:3,4,5,6

// 3.把切片片段拷贝到切片中
s1 := []int {1, 2}
s2 := []int {3, 4, 5, 6}
copy(s1, s2[1:])
fmt.Println(s1)  // s1:4,5
fmt.Println(s2)  // s2:3,4,5,6
```

#### 开发要点

- 声明slice最好是提前预估好cap，因为slice超过cap时会新开辟内存并进行拷贝，影响性能。

- 绝对不要用指针指向slice。slice本身已经是一个引用类型，所以它本身就是一个指针。

- slice是引用，所以修改slice时，对应的数组或切片也会进行修改。

- append可以向slice追加值或切片，如果超过了长度会新创建一个2倍于现在长度的内存空间并进行拷贝，如果旧切片长度超过1024，append会增加旧切片的1/4。

- slice不支持直接比较

#### 面试题

```go
s := make([]string, 5, 10)
for i := 0; i < 12; i++ {
	s = append(s, fmt.Sprintf("%v", i))
}
fmt.Printf("内容：%v---长度：%d---容量%d\n", s, len(s), cap(s))

// 输出
// 内容：[     0 1 2 3 4 5 6 7 8 9 10 11]---长度：17---容量20
```



# map

**key**

- 可以用来做key的类型，`int`,`string`, `float32（64）`, `指针`, `接口`。

- 不可用来做key的类型，`数组`, `切片`, `结构体`

**value**

- value可以是任意类型

**map的声明**

普通声明

```go
// 一
var m map[string]string = map[string]string{"K":"Kang"}

// 二
var m map[string]string
m = map[string]string{"K": "kang", "X": "Xuan"}

// 三
m := map[string]string{"K":"Kangxuan"}
```

make声明

```go
m := make(map[string]string)
m["K"] = "Kang"
```

**容量**

- map可以通过key-value动态增长，不存在固定长度和最大限制。

- 出于性能考虑，对于大的 map 或者会快速扩张的 map，即使只是大概知道容量，也最好先标明。

```go
// 声明有cap的map
make(map[keytype]valuetype, cap)
```

**常用的代码**

判断key是否存在

```go
// 如果ok为true则key存在，否则不存在
_, ok := map1[key]

// 和if混合用
if _, ok := map1[key1]; ok {
 // ...
}
```

删除key

```go
// 如果key1不存在的话也不会报错
delete(map1, key1)
```

**开发要点**

- 声明时不用声明长度，因为map是可以动态增长。
- map是一种快速寻找值的理想结构，给定 key，对应的 value 可以迅速定位。
