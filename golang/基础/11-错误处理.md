# 错误定义

**errors类**

```go
// 定义错误
err := errors.New("错误内容...")
```

**用 `fmt` 创建错误对象**

```go
if f < 0 {
    return 0, fmt.Errorf("math: square root of negative number %g", f)
}
```

# panic

**触发panic的场景**

- 当发生像数组下标越界或类型断言失败这样的运行错误时，Go 运行时会触发运行时 `panic`，伴随着程序的崩溃抛出一个 `runtime.Error` 接口类型的值。这个错误值有个 RuntimeError() 方法用于区别普通错误。

- 手动`panic`

**panic实践**

`panic()` 可以直接从代码初始化：当错误条件（我们所测试的代码）很严苛且不可恢复，程序不能继续运行时，可以使用 `panic()` 函数产生一个中止程序的运行时错误。`panic()` 接收一个做任意类型的参数，通常是字符串，在程序死亡时被打印出来。Go 运行时负责中止程序并给出调试信息。

**panicking过程是怎样**

在多层嵌套的函数调用中调用 `panic()`，可以马上中止当前函数的执行，所有的 defer 语句都会保证执行并把控制权交还给接收到 panic 的函数调用者。这样向上冒泡直到最顶层，并执行（每层的）` defer`，在栈顶处程序崩溃，并在命令行中用传给 panic() 的值报告错误情况：这个终止过程就是 `panicking`。

# recover

**recover的概念**

正如名字一样，这个 (`recover()`) 内建函数被用于从 `panic` 或错误场景中恢复：让程序可以从 panicking 重新获得控制权，停止终止过程进而恢复正常执行。

**用recover处理panic错误**

```go
func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered in f", r)
        }
    }()

    panic("错误信息...")
}
```

**defer-panic-and-recover 机制**

- 设计理念
  
  Go 的设计者觉得 `try/catch` 机制的使用太泛滥了，而且从底层向更高的层级抛异常太耗费资源。他们给 Go 设计的机制也可以“捕捉”异常，但是更轻量，并且只应该作为（处理错误的）最后的手段。

- 如何处理普通错误
  
  通过在函数和方法中返回错误对象作为它们的唯一或最后一个返回值——如果返回 `nil`，则没有错误发生——并且主调 (calling) 函数总是应该检查收到的错误。

# 错误处理最佳实践

最佳实践

- 在包内部，总是应该从 `panic` 中 `recover`，不允许显式的超出包范围的 `panic()`。

- 向包的调用者返回错误值（而不是 `panic`）。

- 在包内部，特别是在非导出函数中有很深层次的嵌套调用时，将 `panic` 转换成 `error` 来告诉调用方为何出错，是很实用的（且提高了代码可读性）。
