# 接口

#### 接口的概念

Go语言中的接口是一种**抽象数据类型**，golang中接口定义对象的行为规范，只定义规范不实现，接口中定义的规范由具体的对象来实现。

接口定义了一组方法（方法集），但是这些方法不包含（实现）代码：它们没有被实现（它们是抽象的）。

#### 接口的定义和规范

1. 接口的名字由方法名加 `er` 后缀组成，例如 `Printer`、`Reader`、`Writer`、`Logger`、`Converter` 等等。

2. 接口通常会包含 0 个或最多方法，如果是0个方法就是一个空接口。

3. 调用接口时，接收者是值的方法可以通过指针调用，因为指针会首先被解引用；接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址。

```go
//type 接口名 interface {
//    方法1(参数列表1) 返回列表1
//    方法2(参数列表2) 返回列表2
//}
```

#### 接口的实现

1. 类型（结构体、自定义类型）不需要显式声明它实现了某个接口，接口被隐式地实现。多个类型可以实现同一个接口。

2. 实现某个接口的类型（除了实现接口方法外）可以有其他的方法。

3. 一个类型可以实现多个接口。

4. 接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。

5. 一个包中，实现了某些类型的接口，调用包也可以进行其他类型接口的拓展。

```go
// 定义一个Usb的接口类型
type Usber interface {
	Start()
	Stop()
}

// 定义一个phone的结构体，并细线Usb接口，要实现Usb接口，就要实现Usb中所有的方案
type Phone struct {
	Name string
}

// 下面是phone结构体实现了Usb中所有的方法，以此来实现Usb接口
func (p Phone) Start() {
	fmt.Printf("%v开机\n", p.Name)
}

func (p Phone) Stop() {
	fmt.Printf("%v关机\n", p.Name)
}

// 也可以有其他方法
func (p Phone) Call() {
	fmt.Printf("%v打电话\n", p.Name)
}

func main() {
	// 先实例化Phone
	xmPhone := Phone{
		Name: "小米",
	}
	// 实例化接口并将xmPhone赋值给该接口
	var p Usber = xmPhone
	// 通过接口实例调用
	p.Start() // 小米开机
	p.Stop()  // 小米关机
	//p.Call() 接口没有定义Call方法不可调用
	// 当然也可以通过结构体实例调用方法
	xmPhone.Start() // 小米开机
	xmPhone.Stop()  // 小米关机
	xmPhone.Call()  // 小米打电话
}
```

实际中的例子

```go
// 定义一个蓝牙的接口
type Bluetoother interface {
	Connect()
}

// 定义一个Phone结构体并实现Bluetoother
type Phone struct {
	Name string
}

// 实现Connect方法以此来实现接口Bluetoother
func (p Phone) Connect() {
	fmt.Printf("%v手机连接上了蓝牙\n", p.Name)
}

// 定义一个键盘结构体并实现Bluetoother
type Keyboard struct {
	Name string
}

// 实现Connect方法以此来实现接口Bluetoother
func (k Keyboard) Connect() {
	fmt.Printf("%v键盘关连接上了蓝牙\n", k.Name)
}

// 定义一个电脑的结构体
type Computer struct {
}

// 要想连接电脑的蓝牙要求必须传入BlueToother接口类型
func (c Computer) ConnectBluetooth(blueTooth Bluetoother) {
	blueTooth.Connect()
}

func main() {
	// 实例化Computer
	computer := Computer{}
	// 实例化Phone
	xmPhone := &Phone{
		Name: "小米",
	}
	// 实例化键盘
	flKeyboard := &Keyboard{
		Name: "FILCO",
	}
	// 实例化接口
	var b1 Bluetoother = xmPhone
	var b2 Bluetoother = flKeyboard

	computer.ConnectBluetooth(b1)
	computer.ConnectBluetooth(b2)
}
```



#### 接口嵌套

- 一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。

- 嵌套接口中的方法名称不能相同。

**类型断言**

判断接口是否包含了某种类型

- `if-ok`模式

```go
// if v, ok := varI.(T); ok，其中varI必须是接口变量，T为类型(接口定义的类型)。
type Person interface {
    Speaking() string
}

type Student struct {
    name string
}

// Student结构体实现了Speaking方法也就实现了Person接口
func (s *Student) Speaking() string {
    sayHello := "Hi, My name is:" + s.name
    return sayHello
}

func main() {
    st1 := &Student{"shanla"}
    fI(st1)
}

func fI(i interface{}) {
    if i, ok := i.(Person); ok {
        sayHello := i.Speaking()
        fmt.Println("speaking:", sayHello)
    } else {
        fmt.Println("未实现")
    }
}
```

- `type-switch`模式

```go
// Simpler是接口
func fI(it interface{}) int {
 switch it.(type) {
 case *Simple:
     it.Set(5)
     return it.Get()
 case *RSimple:
     it.Set(50)
     return it.Get()
 default:
     return 99
 }   
 return 0
}
```

#### 空接口

Go语言中的接口可以不用定义任何方法，没有定义任何方法的接口称为空接口。空接口表示没有任何约束，因此任何类型变量都可以实现空接口。

```go
// any 或 Any 是空接口一个很好的别名或缩写
type Any interface {}
```

- 任何其他类型都实现了空接口，所以可以给一个空接口类型的变量` var val interface {} `赋任何类型的值。

- 每个 ` interface {}` 变量在内存中占据两个字长：一个用来存储它包含的类型，另一个用来存储它包含的数据或者指向数据的指针。

```go
func main() {
	var x interface{}
	s:="hello"
	x=s
	fmt.Printf("Type：%T，Value：%v\n",x,x) // 输出：Type：string，Value：hello

	i:=100
	x=i
	fmt.Printf("Type：%T，Value：%v\n",x,x) // 输出：Type：int，Value：100

	b:=true
	x=b
	fmt.Printf("Type：%T，Value：%v\n",x,x) // 输出：Type：bool，Value：true
}
```

**1、空接口作为参数**

```go
func show(a interface{}) {
	fmt.Printf("Type：%T，Value：%v\n",a,a)
}

func main() {
	show("hello")
	show(100)
	show(true)
}
```

**2、map的值实现空接口**

用来存储任意类型的map

```go
// 定义一个值为空接口的map，实现存储任意类型的数据
var m map[string]interface{}
m=make(map[string]interface{})
m["name"]="张三"
m["age"]=18
m["isMarried"]=false
fmt.Println(m)
```

**3、切片实现空接口**

用来存储任意类型的切片

```go
// 定义一个值为空接口的切片，实现存储任意类型的数据
var s []interface{}
s=make([]interface{},0,10)
s=append(s,100,"hello",true)
fmt.Println(s)
```

#### 断言

想要判断一个空接口的值的类型，可以使用类型断言。

```go
func justifyType(v interface{}){
	switch v.(type) {
	case int:
		fmt.Println("是int类型")
	case float32,float64:
		fmt.Println("是float类型")
	case string:
		fmt.Println("是string类型")
	case bool:
		fmt.Println("是bool类型")
	default:
		fmt.Println("未知类型")
	}
}

func main() {
	var a interface{}
	a = 100
	v,ok:=a.(int)
	if !ok {
		fmt.Println("a不是int类型")
	} else {
		fmt.Println("a是int类型，值为：",v)
	}

	b:=10.4
	a=b
	justifyType(a)
}
```

#### 结构体值接收者和指针接收者实现接口的区别

如果是值接收者，实例化后的结构体值类型和结构体指针类型都可以赋值给接口变量。

如果是指针接收者，只有结构体指针类型可以复制给接口变量

```go

type Usb interface {
	Start()
	Stop()
}

type Phone struct {
	Name string
}

func (p Phone) Start() {
	fmt.Println(p.Name,"手机开始工作")
}

func (p Phone) Stop() {
	fmt.Println(p.Name,"手机停止工作")
}

type Camera struct {
	Name string
}

func (c *Camera) Start() {
	fmt.Println(c.Name,"相机开始工作")
}

func (c *Camera) Stop() {
	fmt.Println(c.Name,"相机停止工作")
}

func main() {
	 // 接收者是值类型，既可以接收值类型，也可以接收指针类型
	 phone1:=Phone{Name:"iphone"}

	 var p1 Usb=phone1
	 p1.Start()
	 p1.Stop()

	 phone2:=&Phone{Name:"huawei"}
	 var p2 Usb=phone2
	 p2.Start()
	 p2.Stop()

	 // 接收者是指针类型，只能接收指针类型，不能接收值类型，所以下面这行会报错
	 camera1:=Camera{Name:"nikon"}
	 var c1 Usb=camera1
	 c1.Start()
	 c1.Stop()

	 camera2:=&Camera{Name:"sony"}
	 var c2 Usb=camera2
	 c2.Start()
}
```

#### 实现多个接口

一个结构体或自定义类型可以实现多个接口，当结构体实例赋值给接口时，接口只能调用其定义的方法。

```go

```

# 反射

**反射的概念**

- 反射是用程序检查其所拥有的结构，尤其是类型的一种能力；这是元编程的一种形式。

- 反射可以在运行时检查类型和变量，例如：它的大小、它的方法以及它能“动态地”调用这些方法，这对于没有源代码的包尤其有用。

- 这是一个强大的工具，除非真得有必要，否则应当避免使用或小心使用。

**reflect包**

- `reflect.TypeOf`获得任意值的类型对象

- `reflect.ValueOf`返回任意值的原始值的值信息

**反射操作**

反射的方法示例：

```go
// 反射出x的类型
t := reflect.TypeOf(x)
// 反射出x的值
v := reflect.ValueOf(x)

// Type()返回对应的v的类型
fmt.Println("type:", v.Type())
// Kind()返回v的最底层类型
fmt.Println("kind:", v.Kind())
// 如果类型是float，通过v.Float()可以获得值。
fmt.Println("value:", v.Float())
// Interface将v的当前值作为一个interface{}返回
fmt.Println(v.Interface())
fmt.Printf("value is %5.2e\n", v.Interface())
y := v.Interface().(float64)
```

通过反射修改值示例：

```go
// 通过`v := reflect.ValueOf(&x)`以及`v = v.Elem()`进行设置

// 两种失败的案例
var x float64 = 3.4
v := reflect.ValueOf(x)

// CanSet()返回是否可以设置

// settability of v: false
fmt.Println("settability of v:", v.CanSet())

v = reflect.ValueOf(&x)
// type of v: *float64
fmt.Println("type of v:", v.Type())
// settability of v: false
fmt.Println("settability of v:", v.CanSet())
```

```go
// 成功的案例
v := reflect.ValueOf(&x)
v = v.Elem()
// The Elem of v is: <float64 Value>
fmt.Println("The Elem of v is: ", v)
// settability of v: true
fmt.Println("settability of v:", v.CanSet())
v.SetFloat(3.1415) // this works!
// 3.1415
fmt.Println(v.Interface())
// <float64 Value>
fmt.Println(v)
```

反射结构体示例：

[结构体反射原理](https://www.liwenzhou.com/posts/Go/reflect/#autoid-4-2-0)

```go
type NotknownType struct {
    s1, s2, s3 string
}

// String 如果类型有String()方法，通过fmt.Print打印时会调用这个方法
func (n NotknownType) String() string {
    return n.s1 + "-" + n.s2 + "-" + n.s3
}

var secret interface{} = NotknownType{"Ada", "Go", "Oberon"}

value := reflect.ValueOf(secret) // <main.NotknownType Value>
typ := reflect.TypeOf(secret) // main.NotknownType
// alternative:
// typ := value.Type() // main.NotknownType
fmt.Println(typ)
knd := value.Kind() // struct
fmt.Println(knd)

// iterate through the fields of the struct:
// v.NumField()返回字段数量
// v.Field(i)返回具体某一个字段的值
for i := 0; i < value.NumField(); i++ {
 fmt.Printf("Field %d: %v\n", i, value.Field(i))
 // error: panic: reflect.Value.SetString using value obtained using unexported field
 // value.Field(i).SetString("C#")
}

// call the first method, which is String():
// Method(i)返回具体某一个方法，Call()调用此方法
results := value.Method(0).Call(nil)
fmt.Println(results) // [Ada - Go - Oberon]
```

修改结构字段值示例：

```go
// 通过`v := reflect.ValueOf(&x),Elem()`，并且字段必须是导出字段
type T struct {
    A int
    B string
}

func main() {
    t := T{23, "skidoo"}
    s := reflect.ValueOf(&t).Elem()
    typeOfT := s.Type()
    for i := 0; i < s.NumField(); i++ {
        f := s.Field(i)
        fmt.Printf("%d: %s %s = %v\n", i,
        typeOfT.Field(i).Name, f.Type(), f.Interface())
    }

    s.Field(0).SetInt(11)
    s.Field(1).SetString("Yao")
    fmt.Println("t is now", t)
}

//0: A int = 23
//1: B string = skidoo
//t is now {11 Yao}
```

[GO反射详解](https://juejin.cn/post/6978890144841465869)
