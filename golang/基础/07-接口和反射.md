# 接口

#### 接口的概念

Go语言中的接口是一种**抽象数据类型**，golang中接口定义对象的行为规范，只定义规范不实现，接口中定义的规范由具体的对象来实现。

接口定义了一组方法（方法集），但是这些方法不包含（实现）代码：它们没有被实现（它们是抽象的）。

#### 接口的定义和规范

1. 接口的名字由方法名加 `er` 后缀组成，例如 `Printer`、`Reader`、`Writer`、`Logger`、`Converter` 等等。

2. 接口通常会包含 0 个或最多方法，如果是0个方法就是一个空接口。

3. 调用接口时，接收者是值的方法可以通过指针调用，因为指针会首先被解引用；接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址。

```go
//type 接口名 interface {
//    方法1(参数列表1) 返回列表1
//    方法2(参数列表2) 返回列表2
//}
```

#### 接口的实现

1. 类型（结构体、自定义类型）不需要显式声明它实现了某个接口，接口被隐式地实现。多个类型可以实现同一个接口。

2. 实现某个接口的类型（除了实现接口方法外）可以有其他的方法。

3. 一个类型可以实现多个接口。

4. 接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。

5. 一个包中，实现了某些类型的接口，调用包也可以进行其他类型接口的拓展。

```go
// 定义一个Usb的接口类型
type Usber interface {
    Start()
    Stop()
}

// 定义一个phone的结构体，并细线Usb接口，要实现Usb接口，就要实现Usb中所有的方案
type Phone struct {
    Name string
}

// 下面是phone结构体实现了Usb中所有的方法，以此来实现Usb接口
func (p Phone) Start() {
    fmt.Printf("%v开机\n", p.Name)
}

func (p Phone) Stop() {
    fmt.Printf("%v关机\n", p.Name)
}

// 也可以有其他方法
func (p Phone) Call() {
    fmt.Printf("%v打电话\n", p.Name)
}

func main() {
    // 先实例化Phone
    xmPhone := Phone{
        Name: "小米",
    }
    // 实例化接口并将xmPhone赋值给该接口
    var p Usber = xmPhone
    // 通过接口实例调用
    p.Start() // 小米开机
    p.Stop()  // 小米关机
    //p.Call() 接口没有定义Call方法不可调用
    // 当然也可以通过结构体实例调用方法
    xmPhone.Start() // 小米开机
    xmPhone.Stop()  // 小米关机
    xmPhone.Call()  // 小米打电话
}
```

实际中的例子

```go
// 定义一个蓝牙的接口
type Bluetoother interface {
    Connect()
}

// 定义一个Phone结构体并实现Bluetoother
type Phone struct {
    Name string
}

// 实现Connect方法以此来实现接口Bluetoother
func (p Phone) Connect() {
    fmt.Printf("%v手机连接上了蓝牙\n", p.Name)
}

// 定义一个键盘结构体并实现Bluetoother
type Keyboard struct {
    Name string
}

// 实现Connect方法以此来实现接口Bluetoother
func (k Keyboard) Connect() {
    fmt.Printf("%v键盘关连接上了蓝牙\n", k.Name)
}

// 定义一个电脑的结构体
type Computer struct {
}

// 要想连接电脑的蓝牙要求必须传入BlueToother接口类型
func (c Computer) ConnectBluetooth(blueTooth Bluetoother) {
    blueTooth.Connect()
}

func main() {
    // 实例化Computer
    computer := Computer{}
    // 实例化Phone
    xmPhone := &Phone{
        Name: "小米",
    }
    // 实例化键盘
    flKeyboard := &Keyboard{
        Name: "FILCO",
    }
    // 实例化接口
    var b1 Bluetoother = xmPhone
    var b2 Bluetoother = flKeyboard

    computer.ConnectBluetooth(b1)
    computer.ConnectBluetooth(b2)
}
```

#### 接口嵌套

- 一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。

- 嵌套接口中的方法名称不能相同。

**类型断言**

判断接口是否包含了某种类型

- `if-ok`模式

```go
// if v, ok := varI.(T); ok，其中varI必须是接口变量，T为类型(接口定义的类型)。
type Person interface {
    Speaking() string
}

type Student struct {
    name string
}

// Student结构体实现了Speaking方法也就实现了Person接口
func (s *Student) Speaking() string {
    sayHello := "Hi, My name is:" + s.name
    return sayHello
}

func main() {
    st1 := &Student{"shanla"}
    fI(st1)
}

func fI(i interface{}) {
    if i, ok := i.(Person); ok {
        sayHello := i.Speaking()
        fmt.Println("speaking:", sayHello)
    } else {
        fmt.Println("未实现")
    }
}
```

- `type-switch`模式

```go
// Simpler是接口
func fI(it interface{}) int {
 switch it.(type) {
 case *Simple:
     it.Set(5)
     return it.Get()
 case *RSimple:
     it.Set(50)
     return it.Get()
 default:
     return 99
 }   
 return 0
}
```

#### 空接口

Go语言中的接口可以不用定义任何方法，没有定义任何方法的接口称为空接口。空接口表示没有任何约束，因此任何类型变量都可以实现空接口。

```go
// any 或 Any 是空接口一个很好的别名或缩写
type Any interface {}
```

- 任何其他类型都实现了空接口，所以可以给一个空接口类型的变量` var val interface {} `赋任何类型的值。

- 每个 ` interface {}` 变量在内存中占据两个字长：一个用来存储它包含的类型，另一个用来存储它包含的数据或者指向数据的指针。

```go
func main() {
    var x interface{}
    s:="hello"
    x=s
    fmt.Printf("Type：%T，Value：%v\n",x,x) // 输出：Type：string，Value：hello

    i:=100
    x=i
    fmt.Printf("Type：%T，Value：%v\n",x,x) // 输出：Type：int，Value：100

    b:=true
    x=b
    fmt.Printf("Type：%T，Value：%v\n",x,x) // 输出：Type：bool，Value：true
}
```

**1、空接口作为参数**

```go
func show(a interface{}) {
    fmt.Printf("Type：%T，Value：%v\n",a,a)
}

func main() {
    show("hello")
    show(100)
    show(true)
}
```

**2、map的值实现空接口**

用来存储任意类型的map

```go
// 定义一个值为空接口的map，实现存储任意类型的数据
var m map[string]interface{}
m=make(map[string]interface{})
m["name"]="张三"
m["age"]=18
m["isMarried"]=false
fmt.Println(m)
```

**3、切片实现空接口**

用来存储任意类型的切片

```go
// 定义一个值为空接口的切片，实现存储任意类型的数据
var s []interface{}
s=make([]interface{},0,10)
s=append(s,100,"hello",true)
fmt.Println(s)
```

#### 断言

想要判断一个空接口的值的类型，可以使用类型断言。

```go
func justifyType(v interface{}){
    switch v.(type) {
    case int:
        fmt.Println("是int类型")
    case float32,float64:
        fmt.Println("是float类型")
    case string:
        fmt.Println("是string类型")
    case bool:
        fmt.Println("是bool类型")
    default:
        fmt.Println("未知类型")
    }
}

func main() {
    var a interface{}
    a = 100
    v,ok:=a.(int)
    if !ok {
        fmt.Println("a不是int类型")
    } else {
        fmt.Println("a是int类型，值为：",v)
    }

    b:=10.4
    a=b
    justifyType(a)
}
```

#### 结构体值接收者和指针接收者实现接口的区别

如果是值接收者，实例化后的结构体值类型和结构体指针类型都可以赋值给接口变量。

如果是指针接收者，只有结构体指针类型可以复制给接口变量

```go
type Usb interface {
    Start()
    Stop()
}

type Phone struct {
    Name string
}

func (p Phone) Start() {
    fmt.Println(p.Name,"手机开始工作")
}

func (p Phone) Stop() {
    fmt.Println(p.Name,"手机停止工作")
}

type Camera struct {
    Name string
}

func (c *Camera) Start() {
    fmt.Println(c.Name,"相机开始工作")
}

func (c *Camera) Stop() {
    fmt.Println(c.Name,"相机停止工作")
}

func main() {
     // 接收者是值类型，既可以接收值类型，也可以接收指针类型
     phone1:=Phone{Name:"iphone"}

     var p1 Usb=phone1
     p1.Start()
     p1.Stop()

     phone2:=&Phone{Name:"huawei"}
     var p2 Usb=phone2
     p2.Start()
     p2.Stop()

     // 接收者是指针类型，只能接收指针类型，不能接收值类型，所以下面这行会报错
     camera1:=Camera{Name:"nikon"}
     var c1 Usb=camera1
     c1.Start()
     c1.Stop()

     camera2:=&Camera{Name:"sony"}
     var c2 Usb=camera2
     c2.Start()
}
```

#### 实现多个接口

一个结构体或自定义类型可以实现多个接口，当结构体实例赋值给接口时，接口只能调用其定义的方法。

```go
type Ainterface interface {
    Write()
}

type Binterface interface {
    Read()
}

type Stu struct {
    Name string
    Age int
}

func (stu Stu) Write() {
    fmt.Println(stu.Name,"写作")
}

func (stu Stu) Read() {
    fmt.Println(stu.Name,"读书")
}

func main() {
    stu:=&Stu{Name:"张三",Age:18}
    var a Ainterface=stu
    a.Write()

    var b Binterface=stu
    b.Write()
}
```

#### 接口嵌套

可以通过组合的方式实现接口的嵌套，形成一个新的接口

```go

```

# 反射

#### 反射基本介绍

反射是指在程序运行期间对程序本身进行访问和修改的能力。正常情况程序在编译时，变量

被转换为内存地址，变量名不会被编译器写入到可执行部分。

在运行程序时，程序无法获取自身的信息。支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。

#### 反射常用使用场景

1. 反射可以在程序运行期间动态的获取变量的各种信息，比如变量的类型、类别。

2. 如果是结构体，通过反射还可以获取结构体本身的信息，比如结构体的字段、结构体的方法、结构体的 tag。

3. 通过反射，可以修改变量的值，可以调用关联的方法。

#### reflect包

1. `reflect.TypeOf`获得任意值的类型对象

2. `reflect.ValueOf`返回任意值的原始值的值信息

#### 反射操作

**反射的方法示例：**

```go
// 反射出x的类型
t := reflect.TypeOf(x)
// 反射出x的值
v := reflect.ValueOf(x)

// Type()返回对应的v的类型
fmt.Println("type:", v.Type())
// Kind()返回v的最底层类型
fmt.Println("kind:", v.Kind())
// 如果类型是float，通过v.Float()可以获得值。
fmt.Println("value:", v.Float())
// Interface将v的当前值作为一个interface{}返回
fmt.Println(v.Interface())
fmt.Printf("value is %5.2e\n", v.Interface())
y := v.Interface().(float64)
```

**反射类型：**

```go
func reflectType(v interface{}) {
    t := reflect.TypeOf(v)
    fmt.Printf("Type:%v\n", t)
}

func main() {
    var x float64 = 100.01
    reflectType(x)

    var y int64 = 100
    reflectType(y)
}
```

执行结果：

```shell
Type:float64
Type:int64
```

#### 反射中的Type和Kind

在反射中关于类型还划分为两种：类型（Type）和种类（Kind）。因为在 Go 语言中我们可

以使用 type 关键字构造很多自定义类型，而种类（Kind）就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到种类（Kind）。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。

Go 语言的反射中像数组、切片、Map、指针等类型的变量，它们的.Name()都是返回空。

```go
func reflectType(v interface{}) {
    t := reflect.TypeOf(v)
    fmt.Printf("Type:%v, Name:%v, Kind:%v\n", t, t.Name(), t.Kind())
}

type myInt int64
type Person struct {
    Name string
    Age int
}
type Animal struct {
    Name string
}

func main() {
    var a *float32 // 指针
    var b myInt // 自定义类型
    var c rune // 类型别名

    reflectType(a)
    reflectType(b)
    reflectType(c)

    var d = Person{
        Name: "itying", 
        Age: 18, 
    }
    var e = Animal{Name: "小花"}
    reflectType(d)
    reflectType(e)

    var f = []int{1, 2, 3, 4, 5}
    reflectType(f)
}
```

执行结果：

```shell
Type:*float32, Name:, Kind:ptr
Type:main.myInt, Name:myInt, Kind:int64
Type:int32, Name:int32, Kind:int32
Type:main.Person, Name:Person, Kind:struct
Type:main.Animal, Name:Animal, Kind:struct
Type:[]int, Name:, Kind:slice
```

**在 reflect 包中定义的 Kind 类型如下：**

```go
const (
    Invalid Kind = iota // 非法类型
    Bool // 布尔型
    Int // 有符号整型
    Int8 // 有符号 8 位整型
    Int16 // 有符号 16 位整型
    Int32 // 有符号 32 位整型
    Int64 // 有符号 64 位整型
    Uint // 无符号整型
    Uint8 // 无符号 8 位整型
    Uint16 // 无符号 16 位整型
    Uint32 // 无符号 32 位整型
    Uint64 // 无符号 64 位整型
    Uintptr // 指针
    Float32 // 单精度浮点数
    Float64 // 双精度浮点数
    Complex64 // 64 位复数类型
    Complex128 // 128 位复数类型
    Array // 数组
    Chan // 通道
    Func // 函数
    Interface // 接口
    Map // 映射
    Ptr // 指针
    Slice // 切片
    String // 字符串
    Struct // 结
    UnsafePointer // 底层指针
}
```

**通过反射修改值示例：**

```go
// 通过`v := reflect.ValueOf(&x)`以及`v = v.Elem()`进行设置

// 两种失败的案例
var x float64 = 3.4
v := reflect.ValueOf(x)

// CanSet()返回是否可以设置

// settability of v: false
fmt.Println("settability of v:", v.CanSet())

v = reflect.ValueOf(&x)
// type of v: *float64
fmt.Println("type of v:", v.Type())
// settability of v: false
fmt.Println("settability of v:", v.CanSet())
```

```go
// 成功的案例
v := reflect.ValueOf(&x)
v = v.Elem()
// The Elem of v is: <float64 Value>
fmt.Println("The Elem of v is: ", v)
// settability of v: true
fmt.Println("settability of v:", v.CanSet())
v.SetFloat(3.1415) // this works!
// 3.1415
fmt.Println(v.Interface())
// <float64 Value>
fmt.Println(v)
```

反射结构体示例：

[结构体反射原理](https://www.liwenzhou.com/posts/Go/reflect/#autoid-4-2-0)

```go
type NotknownType struct {
    s1, s2, s3 string
}

// String 如果类型有String()方法，通过fmt.Print打印时会调用这个方法
func (n NotknownType) String() string {
    return n.s1 + "-" + n.s2 + "-" + n.s3
}

var secret interface{} = NotknownType{"Ada", "Go", "Oberon"}

value := reflect.ValueOf(secret) // <main.NotknownType Value>
typ := reflect.TypeOf(secret) // main.NotknownType
// alternative:
// typ := value.Type() // main.NotknownType
fmt.Println(typ)
knd := value.Kind() // struct
fmt.Println(knd)

// iterate through the fields of the struct:
// v.NumField()返回字段数量
// v.Field(i)返回具体某一个字段的值
for i := 0; i < value.NumField(); i++ {
 fmt.Printf("Field %d: %v\n", i, value.Field(i))
 // error: panic: reflect.Value.SetString using value obtained using unexported field
 // value.Field(i).SetString("C#")
}

// call the first method, which is String():
// Method(i)返回具体某一个方法，Call()调用此方法
results := value.Method(0).Call(nil)
fmt.Println(results) // [Ada - Go - Oberon]
```

修改结构字段值示例：

```go
// 通过`v := reflect.ValueOf(&x),Elem()`，并且字段必须是导出字段
type T struct {
    A int
    B string
}

func main() {
    t := T{23, "skidoo"}
    s := reflect.ValueOf(&t).Elem()
    typeOfT := s.Type()
    for i := 0; i < s.NumField(); i++ {
        f := s.Field(i)
        fmt.Printf("%d: %s %s = %v\n", i,
        typeOfT.Field(i).Name, f.Type(), f.Interface())
    }

    s.Field(0).SetInt(11)
    s.Field(1).SetString("Yao")
    fmt.Println("t is now", t)
}

//0: A int = 23
//1: B string = skidoo
//t is now {11 Yao}
```

[GO反射详解](https://juejin.cn/post/6978890144841465869)
