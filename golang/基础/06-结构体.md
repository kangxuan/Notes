# 结构体

#### 结构体的概念

- 一个带属性的结构体试图表示一个现实世界中的实体。

- 当需要定义一个类型，它由一系列属性组成，每个属性都有自己的类型和值的时候，就应该使用结构体，它把数据聚集在一起，所以结构体是复合类型。

- 结构体也是值类型，因此可以通过`new`函数来创建。

- 组成结构体类型的那些数据称为字段 (`fields`)。每个字段都有一个类型和一个名字，在一个结构体中，字段名字必须是唯一的。

- 结构体的字段可以是任何类型，甚至是结构体本身。

- 结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套有其他的结构体，这在性能上带来了很大的优势。

- 因为 Go 语言中没有类的概念，一般通过结构体实现。

#### 自定义类型和类型别名

自定义类型和类型别名都是通过type定义的，但自定义类型是定义一个新的类型，而别名则不是。

```go
// 自定义类型
type newInt int

// 给类型去别名
type myInt = int

func main() {
	var a newInt
	var b myInt
	fmt.Printf("%T\n", a) // main.newInt---自定义的类型
	fmt.Printf("%T\n", b) // int --- 别名还是原来的类型
}
```

#### 结构体的定义

```go
// 定义结构体
type identifier struct {
  field1 type1
  field2 type2
  ...
}
```

#### 结构体的实例化

第一种：通过var

```go
type person struct {
	name string
	city string
	age  int
}

// 实例化第一种：通过var
var p1 person
p1.name = "张三"
p1.city = "beijing"
p1.age = 10
fmt.Printf("%#v", p1) // main.person{name:"张三", city:"beijing", age:10}
```

第二种：通过new，得到的是一个指针

```go
type person struct {
	name string
	city string
	age  int
}

var p2 = new(person)
p2.name = "李四"
p2.city = "shanghai"
p2.age = 11
fmt.Printf("%#v\n", p2) // &main.person{name:"李四", city:"shanghai", age:11}
```

第三种：通过&，和new一样得到的是一个指针

```go
type person struct {
	name string
	city string
	age  int
}

// 实例化第三种：通过&
p3 := &person{}
p3.name = "王五"
p3.city = "guangzhou"
p3.age = 100
fmt.Printf("%#v\n", p3) //&main.person{name:"王五", city:"guangzhou", age:100}
```

第四种：键值对初始化

```go
type person struct {
	name string
	city string
	age  int
}

// 实例化第四种：键值对初始化
p4 := person{
	name: "张思",
	city: "chengdu",
	age:  18,
}
fmt.Printf("%#v\n", p4) // main.person{name:"张思", city:"chengdu", age:18}
```

第五种：结构体指针进行键值对初始化

```go
type person struct {
	name string
	city string
	age  int
}
// 实质化第五种：结构体指针键值对初始化
p5 := &person{
	name: "marry",
	city: "new York",
	age:  29,
}
fmt.Printf("%#v\n", p5) // &main.person{name:"marry", city:"new York", age:29}
```

*注意：结构体里的字段都有 名字，像 field1、field2 等，如果字段在代码中从来也不会被用到，那么可以命名它为 _。*

**示例代码**

```go
package main

import (
    "fmt"
    "strings"
)

type Person struct {
    firstName string
    lastName string
}

func upPerson(p *Person) {
    p.firstName = strings.ToUpper(p.firstName)
    p.lastName = strings.ToUpper(p.lastName)
}

func main(){
    // 1-第一种声明方法，作为值类型
    var pers1 Person
    pers1.firstName = "shan"
    pers1.lastName = "la"
    upPerson(&pers1)
    fmt.Println(pers1)
    // 2-第二种声明方法，用new声明出来的为指针
    pers2 := new(Person)
    pers2.firstName = "Chris"
    pers2.lastName = "Woodward"
    fmt.Println(pers2)
    (*pers2).lastName = "hhh" // 指针类型需要通过*取值
    fmt.Println(pers2)
    // 3-第三种声明方法，字面量声明
    pers3 := &Person{"shanla", "la"}
    pers3.lastName = "chun"
    upPerson(pers3)
    fmt.Println(pers3)
}
```

#### 结构体方法和接收者

在Go语言中，没有类的概念，但可以给类型（结构体和自定义类型）定义方法。所谓方法就是定义接收者的函数，接收者的概念类似于其他语言中的self或this。

值类型接收者不会修改结构体实例，因为传入的是一个副本；

指针类型接收者会修改结构体实例，引入传入的是实例的地址；

```go
type person struct {
	nickname string
	city     string
}

// 值类型的接收者，调用时传入拷贝一个副本，在方法内修改不会修改实例的值
func (p person) printInfo() {
	p.nickname = "李四"
	fmt.Printf("%v所在的城市是：%v\n", p.nickname, p.city)
}

// 指针类型的接收者，调用时传入实例的地址，在方法内修改会修改实例的值
func (p *person) setInfo(name string, city string) {
	p.nickname = name
	p.city = city
}

func main() {
	p := person{
		nickname: "张三",
		city:     "beijing",
	}
	p.printInfo()           // 李四所在的城市是：beijing
	fmt.Println(p.nickname) // 张三

	p.setInfo("王五", "shanghai")
	fmt.Printf("%#v\n", p) // main.person{nickname:"王五", city:"shanghai"}
}
```

给其他类型定义方法

```go
// 自定义类型
type MyInt int

// 给自定义变量定义方法
func (i MyInt) printInfo() {
	fmt.Printf("值：%v---类型：%T\n", i, i)
}

func main() {
	i := MyInt(10)
	i.printInfo()
}
```



#### 字段标签

```go
import (
 "fmt"
 "reflect"
)

type TagType struct {
    field1 bool "This is bool type" // 字段标签
    field2 int "This is int type"
    field3 string "This is string type"
}

// refTag 获取字段标签依赖于reflect方法
func refTag(tt TagType, ix int) {
    ttType := reflect.TypeOf(tt)
    ixField := ttType.Field(ix)
    fmt.Printf("%v\n", ixField.Tag)
}
```

**结构体类型**

递归结构体（单链表）

```go
type Node struct {
    data float64
    su *Node
}
```

双向链表

```go
type Node struct {
    pr *Node
    data float64
    su *Node
}
```

匿名结构体

```go
type person struct {
    Name string
    Age int
    Contact struct {
        Phone, Address string
    }
}
```

嵌入结构（类似类继承）

- 示例一

```go
// human结构
type human struct {
    Gender int 
    Name string
    Age int 
}

// teacher结构
type teacher struct {
    human // 内嵌human结构
    subject string // 学科
}

// student结构
type student struct {
    human // 内嵌human结构
    class string // 班级
}


func main() {
    teac1 := &teacher{human: human{Gender: 1, Name: "shanla", Age: 30}, subject: "数学"}
    stu1 := &student{human: human{2, "shijia", 9}, class: "三年二班"}
    // 如果嵌入结构的字段是唯一的，可以直接用
    stu1.Name = "李傻傻"
    // 写明结构路径
    teac1.human.Name = "kangxuan"
    fmt.Println(teac1)
    fmt.Println(stu1)
}
```

- 示例二

```go
// 内嵌字段相同时允许的，因为B、C不是和A.Name同级。
type A struct {
    B
    C
    Name string
}

type B struct {
    Name string
}

type C struct {
    Name string
}

func main() {
    a := A{B: B{Name: "shanla"}, Name: "shanla1", C: C{Name: "shanla2"}}
    fmt.Println(a)
    fmt.Println(a.Name, a.B.Name, a.C.Name)
}
```

**匿名字段**

```go
type innerS struct {
    in1 int 
    in2 int 
}

type outerS struct {
    b int 
    c float32
    int // 匿名字段
    innerS
}

func main() {
    outer := new(outerS)
    outer.b = 6 
    outer.c = 7.
    outer.int = 60
    outer.in1 = 5 
    outer.in2 = 10
}
```

# 结构体方法

**概念**

- Go 方法是作用在接收者 (receiver) 上的一个函数，接收者是某种类型的变量。

- `String()`方法
