# 结构体

#### 结构体的概念

- 一个带属性的结构体试图表示一个现实世界中的实体。

- 当需要定义一个类型，它由一系列属性组成，每个属性都有自己的类型和值的时候，就应该使用结构体，它把数据聚集在一起，所以结构体是复合类型。

- 结构体也是值类型，因此可以通过`new`函数来创建。

- 组成结构体类型的那些数据称为字段 (`fields`)。每个字段都有一个类型和一个名字，在一个结构体中，字段名字必须是唯一的。

- 结构体的字段可以是任何类型，甚至是结构体本身。

- 结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套有其他的结构体，这在性能上带来了很大的优势。

- 因为 Go 语言中没有类的概念，一般通过结构体实现。

#### 自定义类型和类型别名

自定义类型和类型别名都是通过type定义的，但自定义类型是定义一个新的类型，而别名则不是。

```go
// 自定义类型
type newInt int

// 给类型去别名
type myInt = int

func main() {
    var a newInt
    var b myInt
    fmt.Printf("%T\n", a) // main.newInt---自定义的类型
    fmt.Printf("%T\n", b) // int --- 别名还是原来的类型
}
```

#### 结构体的定义

```go
// 定义结构体
type identifier struct {
  field1 type1
  field2 type2
  ...
}
```

#### 结构体的实例化

第一种：通过var

```go
type person struct {
    name string
    city string
    age  int
}

// 实例化第一种：通过var
var p1 person
p1.name = "张三"
p1.city = "beijing"
p1.age = 10
fmt.Printf("%#v", p1) // main.person{name:"张三", city:"beijing", age:10}
```

第二种：通过new，得到的是一个指针

```go
type person struct {
    name string
    city string
    age  int
}

var p2 = new(person)
p2.name = "李四"
p2.city = "shanghai"
p2.age = 11
fmt.Printf("%#v\n", p2) // &main.person{name:"李四", city:"shanghai", age:11}
```

第三种：通过&，和new一样得到的是一个指针

```go
type person struct {
    name string
    city string
    age  int
}

// 实例化第三种：通过&
p3 := &person{}
p3.name = "王五"
p3.city = "guangzhou"
p3.age = 100
fmt.Printf("%#v\n", p3) //&main.person{name:"王五", city:"guangzhou", age:100}
```

第四种：键值对初始化

```go
type person struct {
    name string
    city string
    age  int
}

// 实例化第四种：键值对初始化
p4 := person{
    name: "张思",
    city: "chengdu",
    age:  18,
}
fmt.Printf("%#v\n", p4) // main.person{name:"张思", city:"chengdu", age:18}
```

第五种：结构体指针进行键值对初始化

```go
type person struct {
    name string
    city string
    age  int
}
// 实质化第五种：结构体指针键值对初始化
p5 := &person{
    name: "marry",
    city: "new York",
    age:  29,
}
fmt.Printf("%#v\n", p5) // &main.person{name:"marry", city:"new York", age:29}
```

*注意：结构体里的字段都有 名字，像 field1、field2 等，如果字段在代码中从来也不会被用到，那么可以命名它为 _。*

**示例代码**

```go
package main

import (
    "fmt"
    "strings"
)

type Person struct {
    firstName string
    lastName string
}

func upPerson(p *Person) {
    p.firstName = strings.ToUpper(p.firstName)
    p.lastName = strings.ToUpper(p.lastName)
}

func main(){
    // 1-第一种声明方法，作为值类型
    var pers1 Person
    pers1.firstName = "shan"
    pers1.lastName = "la"
    upPerson(&pers1)
    fmt.Println(pers1)
    // 2-第二种声明方法，用new声明出来的为指针
    pers2 := new(Person)
    pers2.firstName = "Chris"
    pers2.lastName = "Woodward"
    fmt.Println(pers2)
    (*pers2).lastName = "hhh" // 指针类型需要通过*取值
    fmt.Println(pers2)
    // 3-第三种声明方法，字面量声明
    pers3 := &Person{"shanla", "la"}
    pers3.lastName = "chun"
    upPerson(pers3)
    fmt.Println(pers3)
}
```

#### 结构体方法和接收者

在Go语言中，没有类的概念，但可以给类型（结构体和自定义类型）定义方法。所谓方法就是定义接收者的函数，接收者的概念类似于其他语言中的self或this。

值类型接收者不会修改结构体实例，因为传入的是一个副本；

指针类型接收者会修改结构体实例，引入传入的是实例的地址；

```go
type person struct {
    nickname string
    city     string
}

// 值类型的接收者，调用时传入拷贝一个副本，在方法内修改不会修改实例的值
func (p person) printInfo() {
    p.nickname = "李四"
    fmt.Printf("%v所在的城市是：%v\n", p.nickname, p.city)
}

// 指针类型的接收者，调用时传入实例的地址，在方法内修改会修改实例的值
func (p *person) setInfo(name string, city string) {
    p.nickname = name
    p.city = city
}

func main() {
    p := person{
        nickname: "张三",
        city:     "beijing",
    }
    p.printInfo()           // 李四所在的城市是：beijing
    fmt.Println(p.nickname) // 张三

    p.setInfo("王五", "shanghai")
    fmt.Printf("%#v\n", p) // main.person{nickname:"王五", city:"shanghai"}
}
```

给其他类型定义方法

```go
// 自定义类型
type MyInt int

// 给自定义变量定义方法
func (i MyInt) printInfo() {
    fmt.Printf("值：%v---类型：%T\n", i, i)
}

func main() {
    i := MyInt(10)
    i.printInfo()
}
```

#### 结构体的继承

Go语言中没有继承的概念，是通过组合的方式实现继承。

```go
type Animal struct {
    name string
}

func (a *Animal) run() {
    fmt.Printf("%v会跑\n", a.name)
}

type Dog struct {
    age int
    *Animal
}

func (d *Dog) wangwang() {
    fmt.Printf("%v在汪汪汪\n", d.name)
}

func main() {
    d1 := Dog{
        age: 10,
        Animal: &Animal{
            name: "大黄",
        },
    }

    d1.run()
    d1.wangwang()
}
```

#### json和结构体互相转换

通过json包来实现，需要特别注意的是结构体中私有属性是不能被json包访问到

```go
type Student struct {
    ID     int
    Gender string
    name   string // name私有属性不能被json包访问，所以无法转换
    Sno    string
}

func main() {
    var s1 = Student{
        ID:     1,
        Gender: "男",
        name:   "张三",
        Sno:    "00001",
    }
    fmt.Printf("%#v\n", s1)

    // 转成json
    s1Json, err := json.Marshal(s1)
    if err != nil {
        fmt.Println("jsonEncode fail")
    } else {
        fmt.Printf("%v", string(s1Json)) // main.Student{ID:1, Gender:"男", name:"张三", Sno:"00001"}
    }

    // json字符串转换成结构体实例
    var s2 Student
    err = json.Unmarshal(s1Json, &s2)
    if err != nil {
        fmt.Println("jsonDecode fail")
    } else {
        fmt.Printf("%#v\n", s2) // {"ID":1,"Gender":"男","Sno":"00001"}main.Student{ID:1, Gender:"男", name:"", Sno:"00001"}
    }
}
```

#### 结构体标签

Tag 是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 Tag 在结构体字段的

后方定义，由一对反引号包裹起来，具体的格式如下：

`key1:"value1" key2:"value2"`

结构体 tag 由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结

构体字段可以设置多个键值对 tag，不同的键值对之间使用空格分隔。

注意事项： 为结构体编写 Tag 时，必须严格遵守键值对的规则。结构体标签的解析代码的

容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取

值。例如不要在 key 和 value 之间添加空格。

```go
type Student struct {
    ID     int    `json:"id"` //通过指定 tag 实现 json 序列化该字段时的 key
    Name   string `json:"name"`
    Gender string `json:"gender"`
    Sno    string `json:"sno"`
}

func main() {
    var s1 = Student{
        ID:     1,
        Gender: "男",
        Name:   "李四",
        Sno:    "s0001",
    }
    s1Json, err := json.Marshal(s1)
    if err != nil {
        fmt.Printf("%e\n", err)
    } else {
        fmt.Printf("%v\n", string(s1Json)) // {"id":1,"name":"李四","gender":"男","sno":"s0001"}
    }
}
```

#### 结构体类型

递归结构体（单链表）

```go
type Node struct {
    data float64
    su *Node
}
```

双向链表

```go
type Node struct {
    pr *Node
    data float64
    su *Node
}
```

匿名结构体

```go
type person struct {
    Name string
    Age int
    Contact struct {
        Phone, Address string
    }
}
```

嵌入结构（类似类继承）

- 示例一

```go
// human结构
type human struct {
    Gender int 
    Name string
    Age int 
}

// teacher结构
type teacher struct {
    human // 内嵌human结构
    subject string // 学科
}

// student结构
type student struct {
    human // 内嵌human结构
    class string // 班级
}


func main() {
    teac1 := &teacher{human: human{Gender: 1, Name: "shanla", Age: 30}, subject: "数学"}
    stu1 := &student{human: human{2, "shijia", 9}, class: "三年二班"}
    // 如果嵌入结构的字段是唯一的，可以直接用
    stu1.Name = "李傻傻"
    // 写明结构路径
    teac1.human.Name = "kangxuan"
    fmt.Println(teac1)
    fmt.Println(stu1)
}
```

- 示例二

```go
// 内嵌字段相同时允许的，因为B、C不是和A.Name同级。
type A struct {
    B
    C
    Name string
}

type B struct {
    Name string
}

type C struct {
    Name string
}

func main() {
    a := A{B: B{Name: "shanla"}, Name: "shanla1", C: C{Name: "shanla2"}}
    fmt.Println(a)
    fmt.Println(a.Name, a.B.Name, a.C.Name)
}
```

**匿名字段**

```go
type innerS struct {
    in1 int 
    in2 int 
}

type outerS struct {
    b int 
    c float32
    int // 匿名字段
    innerS
}

func main() {
    outer := new(outerS)
    outer.b = 6 
    outer.c = 7.
    outer.int = 60
    outer.in1 = 5 
    outer.in2 = 10
}
```

# 结构体方法

**概念**

- Go 方法是作用在接收者 (receiver) 上的一个函数，接收者是某种类型的变量。

- `String()`方法
