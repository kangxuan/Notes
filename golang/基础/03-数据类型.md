# 数据类型

### 类型分类

**基础数据类型**

包含`int`、`float`、`bool`、`string`。

**结构化类型**

包含`struct`、`array`、`slice`、`map`、`channel`。

**只描述类型的行为**

比如`interface`。

### 类型别名

**单个定义**

```go
type IZ int
```

**批量定义**

```go
type (
    IZ int
    FZ float32
)
```

*注意：这里并不是真正意义上的别名，因为使用这种方法定义之后的类型可以拥有更多的特性，且在类型转换时必须显式转换。*

**类型转换**

- go只支持显式类型转换

```go
valueOfTypeB = TypeB(valueOfTypeA)
```

- 类型只支持相同底层类型之间的转换

```go
// 从一个取值范围较小的类型转换到一个取值范围较大的类型，不会丢失精度
// float32转换float64不会有问题
var f1 float32 = 10
var f2 float64
f2 = float64(f1)

// 从一个取值范围较大的类型转换到一个取值范围较小的类型，会丢失精度
// float64转换float32有可能丢失精度
var f1 float64 = 10.000000000000000000000000000000000000000000000001
var f2 float32
f2 = float32(f1)

// 数字字符串转换成数字
var a string = "32"
var i int
i = int(a) // 会报错，可用strconv.Atoi(orignStr)

i, _ = strconv.Atoi(a) // _接收一个error
```

# 程序结构

**编写规则**
*注意：只是为了可读性，实际上编译对先声明变量还是先声明函数没有要求*

- 编写顺序建议：
  
  1. import包之后，开始对常量、变量和类型进行定义或声明
  
  2. init()函数
  
  3. main()函数
  
  4. 然后定义其余的函数（可以根据main函数调用的顺序）

- 程序实际执行顺序：
  
  1. 按顺序导入所有被 main 包引用的其它包
  
  2. 如果其他包又导入了其他包，则继续引入，但每个包只会被导入一次
  
  3. 每个包中初始化常量和变量，如果有init()函数，再调用此函数
  
  4. 在完成包导入后，再执行main，初始化常量变量，有init再调用，顺序执行代码

# 常量

**概念**

用于存储不变的数据，如果对常量进行重新赋值，会报错。

**定义和赋值**

```go
const identifier [type] = value
```

举例：

```go
// 显式类型定义
const T string = "1234"
// 隐式类型定义，会自行推断类型
const Pi = 3.1415
// 多个常量同时定义
const a,b,c = 1,2,3
// 常量组定义
// a,b,c==1
const (
    a=1
    b
    c
)
// a==0,b==1,c==2
// 在每遇到一个新的常量块或单个常量声明时， iota 都会重置为 0
const (
    a=iota
    b
    c
)

// a=0，b=2，c=2，d=3，e=1，f=5
// iota会占位
const (
    a=iota
    b=2
    c=iota
    d=iota
    e=1
    f=iota
)
```

**命名规范**

一般采用全大写并采用`_`连接，但要根据具体的项目规定。

**重点**

- 常量的值必须是能够在编译时就能确定。

Go的常量const是属于编译时期的常量，即在编译时期就可以完全确定取值的常量。只支持数字，字符串和布尔，及上述类型的表达式。<u>而切片，数组，正则表达式等等需要在运行时分配空间和执行若干运算才能赋值的变量则不能用作常量</u>。

```go
// 场景1：在编译时能确定c1的值
const c1 = 2/3
// 场景2：因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，会编译报错
const c2 = getNum()
```

- 常量无法寻址，是不能对其取指针操作。

```go
package main

import "fmt"

const j = 100

func main() {
    fmt.Println(&j, j) // 会报错
}
```

# 变量

**定义和赋值**

```go
var identifier [type] = value
```

举例：

```go
// 普通写法
var a int = 1
// 因式分解关键字写法
var (
    a int
    b bool
    str string
)


// 只定义不赋值，会默认值
var a, b, c int
// 不指定type，Go会自动推断
var a, b, c = 1, 2, 3
// := 声明并赋值，Go会自动推断
a, b, c := 1, 2, 3

// 交换变量值
a, b = b, a
// 抛弃值
_, b = 5, 7
// 接收函数返回值
val, err = Func(var1)
```

**变量默认值**

| int         | 0     |
| ----------- | ----- |
| float32(64) | 0.0   |
| bool        | false |
| string      | 空字符串  |
| 指针          | nil   |
| channel     | nil   |

**命名规范**

- 采用驼峰法命名

- 相同作用域中的不能有相同的变量名

**作用域**

- 全局变量
  
  - 声明在函数体外部，可以在包中使用，如果需要被导入到其他包使用需要首字母大写

- 局部变量
  
  - 声明在函数体内，作用域为函数体内
  
  - 声明在if等结构内，作用域则为结构内

**变量类型**

- 值类型

值类型包括基础类型（`int`、`float`、`bool`、`string`）、复合类型（`array`、`struct`），值类型存储在栈中，赋值值类型是通过值拷贝。

- 引用类型

引用类型包括`指针`、`slice`、`maps`、`channel`，引用类型存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。

*注意：变量可以被重新赋值，但是不允许不同类型变量的赋值。float32也无法赋值给float64*

# 基本类型和运算符

# 整型

整型分为两大类：

1. 有符号的：int8、int16、int32、int64

2. 无符号的：uint8、uint16、uint32、uint64

| 类型名    | 范围                                                                    | 占用空间   | 有无符号 |
| ------ | --------------------------------------------------------------------- | ------ | ---- |
| int8   | -128 -> 127(-2^7到2^7-1)                                               | 1个byte | 有    |
| int16  | -32768 -> 32767（-2^15到2^15-1）                                         | 2个byte | 有    |
| int32  | -2,147,483,648 -> 2,147,483,647（-2^31到2^31-1）                         | 4个byte | 有    |
| int64  | -9,223,372,036,854,775,808 -> 9,223,372,036,854,775,807（-2^63到2^63-1） | 8个byte | 有    |
| uint8  | 0->255（0到2^8-1）                                                       | 1个byte | 无    |
| uint16 | 0 -> 65,535（0到2^16-1）                                                 | 2个byte | 无    |
| uint32 | 0 -> 4,294,967,295（0到2^32-1）                                          | 4个byte | 无    |
| uint64 | 0 -> 18,446,744,073,709,551,615（0到2^64-1）                             | 8个byte | 无    |

#### 特殊整型

| 类型名     | 描述                            |
| ------- | ----------------------------- |
| uint    | 在32位系统中是uint32，在64位系统中是uint64 |
| int     | 在32位系统中是int32，在64位系统中是int64   |
| unitpir | 无符号整型，用于存放一个指针                |

```go
var a int8 = 120

fmt.Printf("%T\n", a)         // int8
// 通过unsafe.Sizeof获取变量占用的字节数
fmt.Println(unsafe.Sizeof(a)) // 1个字节
```

#### int不同长度直接转换

小精度转换成大精度，不会导致精度丢失。

```go
var a int8 = 120
var b int16 = int16(a)
fmt.Printf("%T\n", b) // int16
```

# 浮点数

Go语言中支持float32和float64两种类型的浮点数，默认的浮点数是float64

| 类型名     | 类型  | 范围                           |
| ------- | --- | ---------------------------- |
| float32 | 浮点型 | +- 1e-45 -> +- 3.4 * 1e38    |
| float64 | 浮点型 | +- 5 * 1e-324 -> 107 * 1e308 |

输出浮点数通过%f。

```go
f := 3.14
fmt.Printf("值：%f---类型：%T\n", f, f) // 默认是float64

fmt.Printf("%f\n", math.Pi)   // 保留6位小数
fmt.Printf("%.2f\n", math.Pi) // 保留2位小数
```

通过第三方包`decimal`来解决精度丢失问题。

# 布尔值

Go语言中布尔类型只有false和true两种状态，不允许将整型强制转换成布尔型，布尔无法参与数值运算，也无法与其他类型进行转换。

```go
var t bool
fmt.Printf("值：%v---类型：%T---占用字节数：%d\n", t, t, unsafe.Sizeof(t)) //值：false---类型：bool---占用字节数：1
```

# byte和rune

组成每个字符的元素叫字符，可通过遍历字符串元素获得字符，字符用单引号包起来。

```go
a := 'a'
b := 'b'

// 当我们直接输出 byte（字符）的时候输出的是这个字符对应的码值
fmt.Println(a) // 97
fmt.Println(b) // 98

// 如果想直接输入字符需要进行%c格式化输出
fmt.Printf("%c---%c\n", a, b) // a---b
```

Go语言中使用byte类型代表一个字符，使用rune类型代表一个UTF-8字符。所以通常使用rune来代表中文的一个字，一个英文占用1个byte，一个汉字占用3个byte。

#### 遍历通用字符串

```go
// 遍历通用字符串
var str = "你好golang"
// 通过for遍历时是根据每一个字节进行遍历，所以一个汉字被分成3个字节
for i := 0; i < len(str); i++ { // byte
    fmt.Printf("%v(%c) ", str[i], str[i])
}
// 输出：228(ä) 189(½) 160( ) 229(å) 165(¥) 189(½) 103(g) 111(o) 108(l) 97(a) 110(n) 103(g)

fmt.Println()

// 所以一般通过for range来遍历，他是通过rune来遍历
for _, v := range str { // rune
    fmt.Printf("%v(%c) ", v, v)
}
// 输出：20320(你) 22909(好) 103(g) 111(o) 108(l) 97(a) 110(n) 103(g) 
```

# 进制类型

| decimal     | 十进制  | 无需前缀    |
| ----------- | ---- | ------- |
| binary      | 二进制  | 前缀0b、0B |
| octal       | 八进制  | 前缀0o、oO |
| hexadecimal | 十六进制 | 前缀0x、0X |

# 字符串

#### Go字符串的概念

字符串是UTF-8字符的一个序列。Go 中的字符串里面的字符也可能根据需要占用 1 至 4 个字节，Go 这样做的好处是不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。

字符串是一种值类型，且值不可变，即创建某个文本后你无法再次修改这个文本的内容，<u>更深入地讲，字符串是字节的定长数组</u>。

```go
str := "hello"
// 字符串不能通过下标直接修改
str[0] = 'H'
fmt.Println(str)
```

以上代码会报错，因为值不可变 创建某个文本后你无法再次修改这个文本的内容

```
error: cannot assign to
```

#### 字符串转义

**解释字符串：** 该类字符串使用双引号括起来，其中的相关的转义字符将被替换。

| \n      | 换行符        |
| ------- | ---------- |
| \r      | 回车符        |
| \t      | tab 键（制表符） |
| \u 或 \U | Unicode 字符 |
| \\      | 反斜杠自身      |
| \a      | 报警声        |
| \b      | 退格         |
| \f      | 换页         |
| \v      | 垂直制表符      |

**非解释字符串：** 该类字符串使用反引号括起来，支持换行(``)

#### 字符串常用操作

| 方法                | 介绍               |
| ----------------- | ---------------- |
| len(str)          | 求字符串的长度，以byte为单位 |
| +或Sprintf         | 拼接字符串            |
| strings.Split     | 分割字符串            |
| strings.Contains  | 判断是否包含           |
| strings.Join      | 拼接字符串，比+效率高      |
| strings.HasPrefix | 前缀判断             |
| strings.HasSuffix | 后缀判断             |
| strings.Index     | 子串首次出现的位置        |
| strings.LastIndex | 子串最后一次出现的位置      |

采用“+”进行拼接，但“+”并不是最高效的方法，可采用`strings.Join()`或`bytes.Buffer`更高效的方式。

```go
// 求字符串长度
var str = "hello 世界，hello golang"
fmt.Printf("%d\n", len(str))                    // 字节长度：27
fmt.Printf("%d\n", utf8.RuneCountInString(str)) // 字符数量：21

// 拼接字符串
strA := "你好"
strB := "世界"

fmt.Printf("%v\n", strA+strB) // 你好世界
joinStr := fmt.Sprintf("%v%v", strA, strB)
fmt.Printf("%v\n", joinStr)                                // 你好世界
fmt.Printf("%v\n", strings.Join([]string{strA, strB}, "")) // 你好世界

// 分割字符串
strC := "Today is a sunny day."
fmt.Printf("%v\n", strings.Split(strC, " ")) // [Today is a sunny day.]

// 是否包含
fmt.Printf("%v\n", strings.Contains(strC, "is")) // true

// 判断前缀和后缀
fmt.Printf("前缀是Today：%v，后缀是day：%v\n", strings.HasPrefix(strC, "Today"), strings.HasSuffix(strC, "day")) // 前缀是Today：true，后缀是day：false

// 判断子串出现的首次和末次位置
fmt.Printf("s出现的首次位置：%d,s出现的末次位置：%d\n", strings.Index(strC, "s"), strings.LastIndex(strC, "s")) // s出现的首次位置：7,s出现的末次位置：11

// 拼接字符串
var strArr = [...]string{"你好", "China", "Love"}
fmt.Printf("%v\n", strings.Join(strArr[:], " ")) // 你好 China Love
```

# 时间格式

主要通过`time`包来实现

```go
package main

import (
    "fmt"
    "time"
)

var week time.Duration

func main() {
    // 返回一个当前时间的time对象
    t := time.Now()
    fmt.Println(t)
    fmt.Printf("%02d.%02d.%02d.%02d.%02d.%04d\n", t.Second(), t.Minute(), t.Hour(), t.Day(), t.Month(), t.Year())

    // 获取上一个时区
    t = time.Now().UTC()
    fmt.Println(t)
    fmt.Println(time.Now())

    week = 60 * 60 * 24 * 7 * 1e9 
    // 加一周
    week_from_now := t.Add(time.Duration(week))
    fmt.Println(week_from_now)

    // 格式化
    fmt.Println(t.Format(time.RFC822))
    fmt.Println(t.Format(time.ANSIC))
    fmt.Println(t.Format("02 Jan 2006 15:04"))
    s := t.Format("20060102")
    fmt.Println(t, "=>", s)

    // 获取当前时间戳
    unix := time.Now().Unix()
}
```

# 指针

#### 声明

```go
// 声明一个指针
var intP *type
// 一个指针变量可以指向任何一个值的内存地址 它指向那个值的内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关。
// 获取指针指向的值
*intP
// 获取指针地址
&intP
// 通过修改*p的值来修改指针指向的值
*intP = 1
```

# 格式化打印

| %g or %G  | 用于格式化浮点数，去掉右边多余的0                                   |
| --------- | --------------------------------------------------- |
| %f        | 用于输出浮点数，并保留6位精度                                     |
| %e        | 输出科学计数表示法                                           |
| %0nd      | 用于规定输出长度n的整数，0为必须，如果达不到位数会往左边补0                     |
| %n.mg     | 表示数字n并精确到小数点m位，还可使用e或f                              |
| %v        | 用于输出复数或格式化输出变量的地址                                   |
| %s        | 用于输出字符串                                             |
| %p        | 用于输出指针（指针存储的是地址）                                    |
| %T        | 用于输出函数                                              |
| %%        | 输出%本体                                               |
| %b（oOdxX） | 整型的不同进制方式显示，b二进制，o八进制小写，O八进制大写，d十进制，x十六进制小写，X十六进制大写 |

# 特别注意

- bool的值只能是true和false，不能通过数字1和0进行隐式转换

- 常量或字面量（比如数字10）不能通过&来获取其地址

- 指针运算不被允许，比如ptr+2，主要是为了保证内存安全（C是可以的）

- 对一个空指针的反向引用是不合法的

- 传递变量的引用比传递变量会更节省内存空间。

# 运算符

运算符优先级

| 7   | ^ !              |
| --- | ---------------- |
| 6   | * / % << >> & &^ |
| 5   | + -              |
| 4   | == != < <= >= >  |
| 3   | <-               |
| 2   | &&               |
| 1   | 或                |

# 位运算

```
// 转成二进制再运算
>> 右移 右移n位就是除以2的n次方。 “a>>b”是把a的各二进位全部右移b位。
<< 左移 左移 n 位就是乘以 2 的 n 次方。 “a<<b”是把 a 的各二进位全部左移 b 位，高位
丢弃，低位补 0。
&  按位与 全1为1
|  按位或 有1为1
^  按位异或 相同为0，不同为1
```
