# 数据类型

### 类型分类

**基础数据类型**

包含`int`、`float`、`bool`、`string`。

**结构化类型**

包含`struct`、`array`、`slice`、`map`、`channel`。

**只描述类型的行为**

比如`interface`。

### 类型别名

**单个定义**

```go
type IZ int
```

**批量定义**

```go
type (
    IZ int
    FZ float32
)
```

*注意：这里并不是真正意义上的别名，因为使用这种方法定义之后的类型可以拥有更多的特性，且在类型转换时必须显式转换。*

**类型转换**

- go只支持显式类型转换

```go
valueOfTypeB = TypeB(valueOfTypeA)
```

- 类型只支持相同底层类型之间的转换

```go
// 从一个取值范围较小的类型转换到一个取值范围较大的类型，不会丢失精度
// float32转换float64不会有问题
var f1 float32 = 10
var f2 float64
f2 = float64(f1)

// 从一个取值范围较大的类型转换到一个取值范围较小的类型，会丢失精度
// float64转换float32有可能丢失精度
var f1 float64 = 10.000000000000000000000000000000000000000000000001
var f2 float32
f2 = float32(f1)

// 数字字符串转换成数字
var a string = "32"
var i int
i = int(a) // 会报错，可用strconv.Atoi(orignStr)

i, _ = strconv.Atoi(a) // _接收一个error
```

# 程序结构

**编写规则**
*注意：只是为了可读性，实际上编译对先声明变量还是先声明函数没有要求*

- 编写顺序建议：
  
  1. import包之后，开始对常量、变量和类型进行定义或声明
  
  2. init()函数
  
  3. main()函数
  
  4. 然后定义其余的函数（可以根据main函数调用的顺序）

- 程序实际执行顺序：
  
  1. 按顺序导入所有被 main 包引用的其它包
  
  2. 如果其他包又导入了其他包，则继续引入，但每个包只会被导入一次
  
  3. 每个包中初始化常量和变量，如果有init()函数，再调用此函数
  
  4. 在完成包导入后，再执行main，初始化常量变量，有init再调用，顺序执行代码

# 常量

**概念**

用于存储不变的数据，如果对常量进行重新赋值，会报错。

**定义和赋值**

```go
const identifier [type] = value
```

举例：

```go
// 显式类型定义
const T string = "1234"
// 隐式类型定义，会自行推断类型
const Pi = 3.1415
// 多个常量同时定义
const a,b,c = 1,2,3
// 常量组定义
// a,b,c==1
const (
    a=1
    b
    c
)
// a==0,b==1,c==2
// 在每遇到一个新的常量块或单个常量声明时， iota 都会重置为 0
const (
    a=iota
    b
    c
)

// a=0，b=2，c=2，d=3，e=1，f=5
// iota会占位
const (
    a=iota
    b=2
    c=iota
    d=iota
    e=1
    f=iota
)
```

**命名规范**

一般采用全大写并采用`_`连接，但要根据具体的项目规定。

**重点**

- 常量的值必须是能够在编译时就能确定。

Go的常量const是属于编译时期的常量，即在编译时期就可以完全确定取值的常量。只支持数字，字符串和布尔，及上述类型的表达式。<u>而切片，数组，正则表达式等等需要在运行时分配空间和执行若干运算才能赋值的变量则不能用作常量</u>。

```go
// 场景1：在编译时能确定c1的值
const c1 = 2/3
// 场景2：因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，会编译报错
const c2 = getNum()
```

- 常量无法寻址，是不能对其取指针操作。

```go
package main

import "fmt"

const j = 100

func main() {
    fmt.Println(&j, j) // 会报错
}
```

# 变量

**定义和赋值**

```go
var identifier [type] = value
```

举例：

```go
// 普通写法
var a int = 1
// 因式分解关键字写法
var (
    a int
    b bool
    str string
)


// 只定义不赋值，会默认值
var a, b, c int
// 不指定type，Go会自动推断
var a, b, c = 1, 2, 3
// := 声明并赋值，Go会自动推断
a, b, c := 1, 2, 3

// 交换变量值
a, b = b, a
// 抛弃值
_, b = 5, 7
// 接收函数返回值
val, err = Func(var1)
```

**变量默认值**

| int         | 0     |
| ----------- | ----- |
| float32(64) | 0.0   |
| bool        | false |
| string      | 空字符串  |
| 指针          | nil   |
| channel     | nil   |

**命名规范**

- 采用驼峰法命名

- 相同作用域中的不能有相同的变量名

**作用域**

- 全局变量
  
  - 声明在函数体外部，可以在包中使用，如果需要被导入到其他包使用需要首字母大写

- 局部变量
  
  - 声明在函数体内，作用域为函数体内
  
  - 声明在if等结构内，作用域则为结构内

**变量类型**

- 值类型

值类型包括基础类型（`int`、`float`、`bool`、`string`）、复合类型（`array`、`struct`），值类型存储在栈中，赋值值类型是通过值拷贝。

- 引用类型

引用类型包括`指针`、`slice`、`maps`、`channel`，引用类型存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。

*注意：变量可以被重新赋值，但是不允许不同类型变量的赋值。float32也无法赋值给float64*

# 基本类型和运算符

**类型取值范围**

| 类型名     | 类型  | 范围                                                      |
| ------- | --- | ------------------------------------------------------- |
| int     | 整型  | 32位系统则为int32、64位系统规则为int64                              |
| int8    | 整型  | -128 -> 127                                             |
| int16   | 整型  | -32768 -> 32767                                         |
| int32   | 整型  | -2,147,483,648 -> 2,147,483,647                         |
| int64   | 整型  | -9,223,372,036,854,775,808 -> 9,223,372,036,854,775,807 |
| uint8   | 整型  | 0 -> 255                                                |
| uint16  | 整型  | 0 -> 65,535                                             |
| uint32  | 整型  | 0 -> 4,294,967,295                                      |
| uint64  | 整型  | 0 -> 18,446,744,073,709,551,615                         |
| unitpir | 整型  | 但足够保存任何一种指针类型，定义在builtin包                               |
| byte    | 整型  | uint8的别名，字节型                                            |
| rune    | 整型  | int32的别名，专门用来处理字符（中文字符和国际字符），截取、统计中文字符的长度               |
| float32 | 浮点型 | +- 1e-45 -> +- 3.4 * 1e38                               |
| float64 | 浮点型 | +- 5 * 1e-324 -> 107 * 1e308                            |

以上范围可以通过`math.MaxInt8`等常量获取

```go
// math/const.go中
const (
 MaxInt8   = 1<<7 - 1
 MinInt8   = -1 << 7
 MaxInt16  = 1<<15 - 1
 MinInt16  = -1 << 15
 MaxInt32  = 1<<31 - 1
 MinInt32  = -1 << 31
 MaxInt64  = 1<<63 - 1
 MinInt64  = -1 << 63
 MaxUint8  = 1<<8 - 1
 MaxUint16 = 1<<16 - 1
 MaxUint32 = 1<<32 - 1
 MaxUint64 = 1<<64 - 1
)

const (
    MaxFloat32             = 3.40282346638528859811704183484516925440e+38  // 2**127 * (2**24 - 1) / 2**23
    SmallestNonzeroFloat32 = 1.401298464324817070923729583289916131280e-45 // 1 / 2**(127 - 1 + 23)

    MaxFloat64             = 1.797693134862315708145274237317043567981e+308 // 2**1023 * (2**53 - 1) / 2**52
    SmallestNonzeroFloat64 = 4.940656458412465441765687928682213723651e-324 // 1 / 2**(1023 - 1 + 52)
)
```

`rune`类型举例，用于操作中文

```go
// 定义一个字符串
var s string = "中国你好"
// 先将s转成rune切片再求len
sr := []rune(s)
fmt.Println(len(sr))
// 截取中文字符
fmt.Println(string(sr[0:1]))
```

**进制**

| decimal     | 十进制  | 无需前缀    |
| ----------- | ---- | ------- |
| binary      | 二进制  | 前缀0b、0B |
| octal       | 八进制  | 前缀0o、oO |
| hexadecimal | 十六进制 | 前缀0x、0X |

# 字符串

**Go字符串的概念**

字符串是UTF-8字符的一个序列。Go 中的字符串里面的字符也可能根据需要占用 1 至 4 个字节，Go 这样做的好处是不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。

字符串是一种值类型，且值不可变，即创建某个文本后你无法再次修改这个文本的内容，<u>更深入地讲，字符串是字节的定长数组</u>。

```go
str := "hello"
// 字符串不能通过下标直接修改
str[0] = 'H'
fmt.Println(str)
```

以上代码会报错，因为值不可变 创建某个文本后你无法再次修改这个文本的内容

```
error: cannot assign to
```

**字符串类型**

- 解释字符串：该类字符串使用双引号括起来，其中的相关的转义字符将被替换。

| \n      | 换行符        |
| ------- | ---------- |
| \r      | 回车符        |
| \t      | tab 键（制表符） |
| \u 或 \U | Unicode 字符 |
| \\      | 反斜杠自身      |
| \a      | 报警声        |
| \b      | 退格         |
| \f      | 换页         |
| \v      | 垂直制表符      |

- 非解释字符串：该类字符串使用反引号括起来，支持换行(``)

**拼接符**

采用“+”进行拼接，但“+”并不是最高效的方法，可采用`strings.Join()`或`bytes.Buffer`更高效的方式。

# 时间格式

主要通过`time`包来实现

```go
package main

import (
    "fmt"
    "time"
)

var week time.Duration

func main() {
    // 返回一个当前时间的time对象
    t := time.Now()
    fmt.Println(t)
    fmt.Printf("%02d.%02d.%02d.%02d.%02d.%04d\n", t.Second(), t.Minute(), t.Hour(), t.Day(), t.Month(), t.Year())

    // 获取上一个时区
    t = time.Now().UTC()
    fmt.Println(t)
    fmt.Println(time.Now())

    week = 60 * 60 * 24 * 7 * 1e9 
    // 加一周
    week_from_now := t.Add(time.Duration(week))
    fmt.Println(week_from_now)

    // 格式化
    fmt.Println(t.Format(time.RFC822))
    fmt.Println(t.Format(time.ANSIC))
    fmt.Println(t.Format("02 Jan 2006 15:04"))
    s := t.Format("20060102")
    fmt.Println(t, "=>", s)

    // 获取当前时间戳
    unix := time.Now().Unix()
}
```

# 指针

**声明**

```go
// 声明一个指针
var intP *type
// 一个指针变量可以指向任何一个值的内存地址 它指向那个值的内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关。
// 获取指针指向的值
*intP
// 获取指针地址
&intP
// 通过修改*p的值来修改指针指向的值
*intP = 1
```

# 格式化打印

| %g or %G  | 用于格式化浮点数，去掉右边多余的0                                   |
| --------- | --------------------------------------------------- |
| %f        | 用于输出浮点数，并保留6位精度                                     |
| %e        | 输出科学计数表示法                                           |
| %0nd      | 用于规定输出长度n的整数，0为必须，如果达不到位数会往左边补0                     |
| %n.mg     | 表示数字n并精确到小数点m位，还可使用e或f                              |
| %v        | 用于输出复数或格式化输出变量的地址                                   |
| %s        | 用于输出字符串                                             |
| %p        | 用于输出指针（指针存储的是地址）                                    |
| %T        | 用于输出函数                                              |
| %%        | 输出%本体                                               |
| %b（oOdxX） | 整型的不同进制方式显示，b二进制，o八进制小写，O八进制大写，d十进制，x十六进制小写，X十六进制大写 |

# 特别注意

- bool的值只能是true和false，不能通过数字1和0进行隐式转换

- 常量或字面量（比如数字10）不能通过&来获取其地址

- 指针运算不被允许，比如ptr+2，主要是为了保证内存安全（C是可以的）

- 对一个空指针的反向引用是不合法的

- 传递变量的引用比传递变量会更节省内存空间。

# 运算符

运算符优先级

| 7   | ^ !              |
| --- | ---------------- |
| 6   | * / % << >> & &^ |
| 5   | + -              |
| 4   | == != < <= >= >  |
| 3   | <-               |
| 2   | &&               |
| 1   | 或                |

# 位运算

```
// 转成二进制再运算
>> 右移
<< 左移
&  按位与 全1为1
|  按位或 有1为1
^  按位异或 相同为0，不同为1
```
