# 控制结构

#### if-else

```go
// if中可以写赋值语句用逗号隔开,变量作用域在if-else结构中
if crond := 10; crond > 10 {
    // dosomething
} else {
    // dosomething
}
// crond的作用域是if内
```

#### switch

```go
// 普通模式
switch value {
    case value1:
    // dosomething
    default:
    // dosomething
}

// case条件模式 switch {case condition}
switch {
    case condition1:
    // dosomething
    default:
    // dosomething
}

// 初始化变量模式 switch initialization {case value}
switch initialization {
    case value1:
    // dosomething
    default:
    // dosomething
}
```

*注意：Go忽略了`break`，会自动跳出，如果想继续执行下一个case使用`fallthrough`，无论下一个case是否达到条件，但也只能跳过一级。*

#### for

```go
// for 初始化语句; 条件语句; 修饰语句 {}
for i:=0; i<5; i++ {

}

// for 条件语句 {}，类似while
var i=0
for i<5 {
    i++
}

// for {}，这种类似do while
for {
    break;
}

// for range，类似其他语言的foreach，用于迭代集合(数组、map、string、slice等)
for ix, val := range coll {

}
```

#### goto

# 函数

#### 变参函数

```go
// 变参函数的声明
func myFunc(a, b, arg ...int) {}
// 调用时，可以传递多个参数，如果是slice传递，必须在最后面添加...
// 如果变参类型不一致可以用两种方式解决
// 1. 结构体
// 2. 空接口
```

#### 函数返回值

Go语言支持多个返回值，且必须由()包裹。

#### 函数类型

Go语言支持将函数定义为一个类型，只要函数满足传参和返回值相同就可以将函数复制给函数变量。

```go
// 定义一个函数类型
type calculation func(int, int) int

// 按照calculation实现就可以赋值给calculation
func add(x int, y int) int {
	return x + y
}

// 按照calculation实现就可以赋值给calculation
func sub(x, y int) int {
	return x - y
}

func main() {
	var c calculation
	c = add
	sum := c(1, 2)
	fmt.Println(sum)

	c = sub
	sub := c(3, 22)
	fmt.Println(sub)
}
```

#### 高阶函数

高阶函数分为将函数作为参数和作为返回值两种情况

```go
// 将函数作为参数
func calc(x, y int, op func(int, int) int) int {
	return op(x, y)
}

func add(x, y int) int {
	return x + y
}

func sub(x, y int) int {
	return x - y
}

func main() {
	sum := calc(1, 2, add)
	fmt.Println(sum)
	sub := calc(3, 2, sub)
	fmt.Println(sub)
}

```

```go
func add(x, y int) int {
	return x + y
}

func sub(x, y int) int {
	return x - y
}

func do(op string) func(int, int) int {
	switch op {
	case "+":
		return add
	case "-":
		return sub
	default:
		return nil
	}
}

func main() {
	var doAdd = do("+")
	fmt.Println(doAdd(1, 3))
	var doSub = do("-")
	fmt.Println(doSub(1, 3))
}
```



#### 匿名函数

```go
// 声明匿名函数
f1 := func {
}

// 调用匿名函数
f1()

// 定义一个匿名函数
fn1 := func(x, y int) {
	fmt.Println(x, y)
}
// 调用匿名函数
fn1(1, 2)

// 自执行匿名函数
func(x, y int) {
	fmt.Println(x, y)
}(1, 2)
```

#### 闭包

函数内调用匿名函数形成闭包

```go
func adder() func(int) int {
	var x int
	return func(y int) int {
		x += y
		return x
	}
}

func main() {
	var f = adder()
	fmt.Println(f(10)) // 10
	fmt.Println(f(10)) // 20
	fmt.Println(f(10)) // 30

	var f1 = adder()
	fmt.Println(f1(10)) // 10
	fmt.Println(f1(10)) // 20
}

```

变量 f 是一个函数并且它引用了其外部作用域中的 x 变量，此时 f 就是一个闭包。 在 f 的生

命周期内，变量 x 也一直有效。

#### defer

关键字 `defer` 允许我们退出到函数返回之前（或任意位置执行 return 语句之后）一刻才执行某个语句或函数。

有多个 `defer` 行为被注册时，它们会以逆序执行（先写的defer后执行、先进后出）。

**运用场景**

- 关闭文件流

- 解锁一个加锁的资源

- 打印最终报告

- 关闭数据库链接

- 实现代码追踪

- 记录函数的参数与返回值

- 异常捕获（配合 `panic` 和 `recover` 使用）

```go
func B() {
    // defer 通过recover对panic进行捕获，一定要放在panic之前，不然捕获不到
    defer func() {
        if err := recover(); err != nil {
            fmt.Println("Recover in B")
        }
    }()
    // 抛出异常
    panic("panic B")
}
```

#### 注意事项

- 在函数调用时，像切片 (slice)、字典 (map)、接口 (interface)、通道 (channel) 这样的引用类型都是默认使用引用传递（即使没有显式的指出指针）

- 尽量使用命名返回值：会使代码更清晰、更简短，同时更加容易读懂

- 返回值赋给了空白符 _，然后自动丢弃掉
