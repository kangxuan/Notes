# 基础

1. char和varchar有什么区别？

```
char: 是定长字符串类型，需要指定长度，指定多少长度就占用多少，和字段值无关。
varchar：是变长字符串类型，也需要指定长度，指定长度是最大占用长度，会根据字段值实际
长度来判断具体占用多少
区别：char比varchar性能更高，因为不用根据具体的值进行扩容。
```

2. 查询的ID在左边补齐7位0

```sql
SELECT LPAD(id, 7, '0') FROM t_user LIMIT 1;
```

3. 查询字段值截取前10位长度的内容，如果本身长度就小于等于10就原样输出，否则最后加上...

```sql
SELECT 
    CASE
    WHEN CHAR_LENGTH(product_name) <= 10 THEN product_name
    ELSE CONCAT(SUBSTRING(product_name, 1, 10),'...')
END AS modified_product_name
FROM product;
```

4. 生成6位随机数

```sql
# 需要向左补齐0，因为生成的随机数可能为0.0011023这样的
select lpad(floor(rand() * 1000000), 6, '0');
```

5. 查询入职天数

```sql
select name, datediff(curdate(), entrydate) as entry_date_num from emp 
order by entry_date_num desc;
```

# 中级

1. 事务的四大特性

```
CAID：
1. 原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
    InnoDB引擎提供了两种事务日志：redo log和undo log，其中redo log保证了持久性，
undo log保证了事务的原子性和隔离性，修改时会生成undo log，当事务执行失败或事务回滚
时，调用undo log来回滚到最初状态（撤销所有已经执行成功的语句）。
2. 一致性：事务应该保证数据库状态从一个一致性状态到另一个一致性状态，一致性状态数据库中
的数据应该满足完整性约束
    一致性包括约束一致性和数据一致性。
3. 隔离性：数据库系统提供的隔离机制，保证事务在外部并发的影响下不受影响，是独立环境下
运行。
4. 持久性：事务提交或回滚后，数据的改变是永久的。
    保证持久性依赖redo log，redo log包含了redo log buffer以及磁盘redo log。当
出现宕机情况，会从redo log重新加载。
```

2. 并发的事务问题

```
1. 脏读
    一个事务读到了另一个事务修改但未提交的数据
    比如A和B事务，B修改了数据但未提交，A读取到数据已经被修改了。
2. 不可重复读
    一个事务先后读取相同数据，两次数据不一致（和幻读相比，关注的是修改）
    比如A和B事务，A先读到数据，B修改数据已经提交，然后A再次读取发现数据不一致。
3. 幻读
    一个事务先查询没有读取到数据，然后插入，再插入或删除时发现数据已经存在
（和不可重复读，关注的是插入和删除）
    比如说A和B事务，A先查询数据不在，B先插入了数据并提交，A插入数据失败，然后再次查询
发现数据已经存在，仿佛出现了“幻象”
```

3. 事务的隔离级别

```
1. 读未提交（RU）
    会出现脏读、不可重复读、幻读
2. 读已提交（RC)（默认）
    不会出现脏读，但会出现不可重复读和幻读
3. 可重复读（RR）
    不会出现脏读、不可重复读，但会出现幻读
4. 串行化（S）
    不会出现脏读、不可重复读、幻读
从上往下隔离级别依次增加，性能依次下降。
```

4. InnoDB和MyISAM的区别

```
InnoDB：
    1. 支持事务
    2. 行级锁
    3. 外键
    4. 更新、删除操作保持数据完整性首选
MyISAM：
    1. 不支持事务
    2. 表锁
    3. 不支持外键
    4. 主要是写入和读取操作时，对数据完整性、一致性要求不高可以选择
```

5. 为什么InnoDB选择B+Tree

```
1. B+Tree相对于二叉树层级更少，搜索效率更高
2. B+Tree相对于B-Tree，同样B-Tree节点不仅存储指针，而且存储数据，这样依然会导致层级
过高
3. B+Tree相对于Hash，B+Tree支持范围查询以及排序操作
```

6. 索引分类

```
按照功能分类：
    1. 主键索引
    2. 普通索引
    3. 唯一索引
    4. 全文索引
按照存储形式分类：
    1. 聚簇索引，主键索引就是聚集索引，最底层子节点中存储了数据，通过索引查找直接返回
    2. 二级索引，普通索引就是二级索引，最底层子节点中只存储了id，还需要去聚集索引中查找
具体的数据，这叫做回表。
```

7. 你在工作中，如何进行SQL性能优化

```
1. 启慢查询日志
2. explain/desc

线上紧急情况：
1. 先大致看看性能低下的原因，特别是线上突发情况，先看是等待时间长还是查询时间长。
2. 再看看性能瓶颈，IO高的估计就是查询问题，CPU高的估计就是排序分组问题，如果带宽的话
就要加大带宽
日常的慢日志优化：
1. 先优化哪些高并发场景情况下的日志
2. 确定优化的目标，比如说是PC后台，要和产品经理协商，优化到什么情况更好
3. explain工具使用
4. 优化的方向：
    代码层面：
        1. 不能使用大循环查询
        2. 禁止使用*查询
        3. 尽量避免过多的join查询
    正确使用索引：
        1. 最左前缀法则
        2. 范围查询，>修改成>=
        3. 最好使用覆盖索引
        4. 模糊查询问题，适当使用全文索引
        5. 手机字符串搜索时不要忘记
        6. or查询要注意两边都要有索引
        7. 长分页查询问题
```

8. 索引的使用规范有哪些？

```
1. 最左前缀法则，只要用到了就OK，如果从左往右，其中一个没有使用，则后面都会失效
2. 范围查询法则，范围查询右侧的索引将会失效，解决方法是使用>=,<=。
3. 覆盖索引法则，查询字段应该是索引字段，不然会导致再次回表，联合索引。
4. 前缀索引法则，针对较长的字符串，应该要考虑创建前缀索引，
计算前缀长度：
select count(distinct email) / count(*) from tb_user;
设置前缀索引：
create index email_5 on tb_user(email(5));
```

9. 索引失效的场景有哪些？

```
1. 索引列使用了列运算则会使该列索引失效
2. 字符串类型不加引号会导致该列索引失效
3. 模糊查询，"xxx%"不会失效，"%xxx"等会失效
4. or，左右两边都要有索引，不然会导致全部失效
5. 数据分布会影响，比如查询id>0等于全表扫描
```

10. 索引设计的原则有哪些？

```
1. 针对常作为where,order by,group by操作的字段建立索引。
2. 尽量选择区分度高的字段建立索引。
3. 对于字符串较长的字段建立前缀索引。
4. 尽量使用联合索引，减少单列索引，因为联合索引大多数可以使用覆盖索引。
5. 要控制索引数量，过多的索引会导致维护成本增加，影响增删改的效率。
6. 索引列不存储NULL，请设置NOT NULL。
```

11. 索引优化有哪些原则？

```
插入数据优化
    大量数据插入：
    1. 通过批量插入法插入数据
    2. 保证主键按顺序插入，乱序容易导致页分裂
    巨量数据插入：
    1. 使用load指令插入
主键优化
    1. 按顺序插入减少页分裂
    2. 主键避免使用uuid，因为太长了
    3. 避免修改主键的值，容易导致页合并等问题
    4. 尽量软删除，容易导致页合并问题
排序优化
    1. 单列排序需要注意查询字段不要超过索引的字段（使用*肯定会导致回表，filesort)
    2. 单列排序字段如果是联合索引也会使用到索引
    3. 多列排序需要建立联合索引才会生效（比如a,b字段单独建立索引，使用
order by a, b，索引不生效），但要满足最左前缀原则，这里和where不一样，顺序也要保持
一致才会生效。
    4. 如果使用asc、desc会导致filesort，如果非要解决这个问题，需要建立特定索引
create index idx_A_B on table_name(A asc,B desc)，但没有必要。InnoDB和MyISAM的区别？
```

13. 5种以上的MySQL的优化建议？

```
1. 最左前缀法则
2. 范围查询原则
3. 覆盖索引原则
4. 查询字段避免使用列运算
5. 尽量使用联合索引避免单列索引
6. 
```

14. 说一下MVCC的内部细节

```
MVCC是多版本并发控制，高并发的数据访问时，对数据进行多版本处理，并通过
事务的可见性来保证事务能看到自己应该看到的版本。
MVCC如何实现：
1. 行记录的三个隐藏字段
    row_id:在表没有主键或唯一索引，InnoDB会给行自动添加一个row_id隐藏列作为主键
    txt_id:事务对该行执行了增删改操作，会将这个事务ID存到txt_id中
    roll_ptr:回滚指针，指向undo log的指针
2. undo log多版本链
    每条数据的每次修改都会产生一个版本，版本之间通过undo log链条来连接的，从而形成了
多版本多版本链。
3. Readview
    Readview是InnoDB实现MVCC时用到的一致性读视图，简单理解就是在每个时刻的状态拍成
照片记录下来，那么之后获取某个时刻的数据就是原来的照片上的数据，不会变化。
    Readview比较重要的四个字段？
    m_ids:用来表示MySQL中正在执行的事务ID
    min_trx_id:就是m_ids中最小的事务ID
    max_trx_id:就是m_ids中最大的事务ID
    creator_trx_id:就是当前事务的ID
    通过Readview判断记录的某个版本是否可见？
    trx_id == creator_trx_id:表示当前事务正在访问自己修改的记录，该版本可见
    trx_id < min_trx_id:表示当前事务在这个版本之前已经提交，所以该版本可见
    trx_id >= max_trx_id:表示当前事务在这个版本之后，所以该版本不可见
    trx_id >= min_trx_id && trx_id < max_trx_id:
        继续判断trx_id是否在m_ids中
            如果在：说明在创建该Readview时，当前事务活跃，所以该版本不可见
            如果不在：说明在创建该Readview时，当前事务已经提交，所以该版本可见
    何时生成Readview快照？
    在RC隔离级别下：每次读取数据前都会生成一个Readview
    在RR隔离级别下：在一个事务中，只在第一次读数据前生成一个Readview。
4. 快照读和当前读
    在MVCC并发控制中，读操作可分为快照读和当前读
        快照读：快照读是当前事务读取的一个快照（undo log链上的某一个版本），他解决了
加锁导致的两个问题：修改时不能读取数据以及读取时不能修改数据
        当前读：当前读应该要读取最新的数据，需要对数据进行加锁
            共享锁：insert/update/delete ... lock in share mode,
            排它锁：select for update
总结：
1. 并发情况下，写-写操作有加锁方案，但为了更一步提高性能，InnoDB提供了MVCC，目的是为了
解决读-写、写-读操作下不加锁也能安全进行。
2. MVCC的本质就是访问版本连，并判断哪个版本可见的过程，该判断算法就是trx_id和Readview
中的各个字段进行判断
3. Readview在不同隔离级别下生成的时机也不同。
```

15. 如何做慢查询优化

```
先开启慢查询日志slow_query_log（可说可不说）
说出慢查询优化的思路（主要）
1. 首先弄清楚SQL性能下降的原因，从等待时间长（锁表导致的）和执行时间长两个方面考虑
2. 优先优化高并发场景的SQL
3. 定位优化对象的性能瓶颈，从三个方面考虑
    IO瓶颈（数据访问消耗太多的时间，查看是否正确使用了索引）
    CPU瓶颈（数据运算消耗太多时间，查看分组和排序是否使用了索引）
    带宽（加大带宽）
4. 明确优化目标，评估具体优化到什么程度合适（结合用户体验和消耗的资源）
5. 从explain入手分析
6. 减少数据库连接的消耗
7. 尽可能在索引中完成排序、分组。
8. 减少*的使用，select *肯定会导致回表问题
9. 尽量只使用最有效的where过滤条件，where条件不是越多越好
10. 尽量避免复杂的join和子查询，join最好不要超过3张表
11. 合理设计并利用索引
    如何判断是否需要创建索引：
        查询频繁的字段应该创建索引
        选择差异性大的字段创建索引
        更新非常频繁的索引最好不要建索引，因为索引维护成本增加
    如何选择合适的索引：
12. 索引失效的一些场景
```

16. InnoDB内存相关参数优化？

```
1. 缓冲池内存大小设置调整
    大的缓冲池内存会减少磁盘IO，建议在专业的rds服务器上，将缓冲池内存大小设置为物理内存
的60%-80%。
    查看当前buffer pool的大小：
        show variables like "%innodb_buffer_pool_size%";
    设置当前buffer pool的大小：
        set global innodb_buffer_pool_size = 13223232323;
2. 评估缓冲池内存大小是否合适
    通过分析缓冲池命中率来验证：
        查看相关参数：
            show status like "%innodb_buffer_pool_read%";
            Innodb_buffer_pool_read_ahead_rnd    0
            Innodb_buffer_pool_read_ahead    63
            Innodb_buffer_pool_read_ahead_evicted    0
            Innodb_buffer_pool_read_requests    58614
            Innodb_buffer_pool_reads    1364
        命中率计算公式：
            Innodb_buffer_pool_read_requests/(Innodb_buffer_pool_reads+Innodb_buffer_pool_read_requests) * 100
        当这个值低于90%，应该考虑增加innodb_buffer_pool_size的大小。
3. Page页大小配置调整
    show global status like "%innodb_buffer_pool_pages%"
```

17. 什么是buffer pool？

```
buffer pool的概念？
buffer pool是缓冲池，简称BP，用来缓存表数据和索引数据，减少磁盘IO操作，提高查询效率。
BP由缓存数据页（page）和对数据页进行描述的控制块组成，控制块中存储着数据页的所属的表
空间、数据页的编号，以及对应缓存数据页在BP中的位置。

BP的默认大小是128M，以Page为单位，Page页默认大小为16K，而控制块的大小约为数据页的5%，
大概字节为800字节。

如何判断一个页是否在BP中？
维护着一个数据页缓存的hash表，将表空间号+页号进行哈希处理对应对应的控制块。
读取一个数据页时，先在hash表中找，如找到则直接使用，如果未找到则从磁盘读取数据放入缓冲页
```

18. BP如何管理数据页的？

```
BP底层采用链表数据结构来管理Page，在InnoDB访问表记录和索引时会在Page页中缓存，以后
使用可以减少磁盘IO，提升效率。
Page根据状态分为三种：free page（空闲page）、clean page（被使用的page，数据未被
修改）、dirty page（脏页）
free list 来管理free page，将一个个空闲的page页放在free链表上
flush list来管理dirty page，将修改过的数据页放入dirtypage中，空闲时刷入磁盘。
lru list用来管理dirty page和clean page，缓冲区以midpoint为基点，链表前面的是热数据
区，存放经常访问的数据，链表后面的是冷数据区，用于存储不经常访问的数据，以此来提高效率。
```

19. 为什么写缓冲区（change buffer）只适用用于非唯一索引？

```
change buffer是为了处理非唯一索引更新操作的一种手段，change buffer在BP中。
要清楚change buffer的更新流程：
在DML操作中，如果用到了唯一索引，就必须校验唯一性，所以需要立马进入BP以及磁盘进行校验，
如果是非唯一索引，先看BP中是否有这个数据，如果有则直接更新BP，再写入redo log，如果BP
中没有这个数据，则先进入BP，因为进入BP从磁盘中获取，这样会多一次IO操作，而是先写入change
buffer中，等待下一次有查询的时候再合并到BP中。
```

20. MySQL为什么会改进Lua淘汰算法？

```
首先要知道普通Lua淘汰算法是什么？
将刚被访问的数据放到链表的头部，不被访问会慢慢移动到链表尾部进行淘汰。
为什么要改进？
因为MySQL查询如果有全表扫描的情况，会将所有的数据放置到链表的头部，这样将真正的热点数据
移动到了链表尾部，这样是有问题的。
```

21. 说一下聚簇索引和非聚簇索引

```
聚簇索引：是将索引和数据存放在一块，索引结构的子节点保存了行数据
非聚簇索引：索引和数据分开存储，索引结构的子节点指向了对应的数据

InnoDB的主键采用的是聚簇索引，二级索引采用的是非聚簇索引。
MyISAM不管是主键索引还是二级索引都是非聚簇索引。

聚簇索引理论上比非聚簇索引效率高，因为不需要去多一次去找数据。
聚簇索引的插入数据依赖顺序插入，不然可能会出现页分裂
尽量避免更新主键的值，会导致页移动。
尽量采用软删除，硬删除容易导致页合并。
二级索引最好只查询索引上的字段，不然会出现回表。
```

22. 索引有哪几种类型？

```
按功能划分：
1. 主键索引
2. 普通索引
3. 联合索引
4. 唯一索引：索引字段必须唯一，允许有空值。
5. 全文索引：全文索引必须是字符串或文本，全文索引字段值必须在3-84之间（MyISAM在4-84）
按存储结构划分：
1. 聚簇索引
2. 二级索引
```

23. 说一下最左前缀法则？

```
联合索引包含了多个字段，查询时需要按照顺序查询，但在where中字段顺序不一致也能用到索引，
是因为MySQL编译时做了优化。

联合索引的存储底层结构：
是根据最左边的字段开始排序，然后再根据第二、第三排序存储的，所以需要遵守最左前缀法则。
```

24. 索引下推是什么意思？

```
索引下推是InnoDB二级索引中减少回表次数的解决方案。当索引查询时，先根据索引来查找然后
再根据where条件先过滤。
```

25. 什么是自适应hash索引

```
1. 自适应哈希索引是当InnoDB引擎根据查询统计发现某一个查询满足hash索引的数据结构特点，
就会创建一个hash索引。
2. hash索引底层的数据结构是hash表。
3. 自适应hash索引只适合做等值查询，且速度比B+Tree要快，因为不需要遍历就可以直接查询
```

26. like查询索引失效的原因是什么？

```
1. %在左边，因为B+Tree的索引顺序是按照最左前缀法则生成的，左边的内容是固定的，可以根据
最左边查询能够用到索引查找。
2. %在右边，因为左边不是固定的，索引用不到索引
3. %在两边，一样是因为左边不是固定的，索引用不到索引
```

27. 主键用自增还是uuid？

```
自增的优点：
1. 自增ID的长度比uuid小很多，占用空间小，检索和排序的性能比uuid高
2. 自增ID是顺序插入的，减少了移动表的带来的开销
自增的缺点：
1. 由于是自增的，很容易被爬虫知道当前的业务量。
2. 在高并发的场景下，竞争自增锁会降低数据库的吞吐量。
3. 数据迁移分库分表会导致自增ID重复。

uuid的优点：
1. uuid不会冲突，数据拆分合并不会导致主键冲突
2. 可以提前生成好，提高数据库吞吐量
uuid的缺点：
1. uuid长度大，占用空间大且不利于减少和排序
2. uuid不是顺序的，插入时有可能会导致页移动。（雪花算法，一定程度是顺序的）
```

28. explain有哪些字段？

```
id:select查询的序列号，表示查询中执行select子句的顺序，id相同，在上面越先执行，id不同
id越大越先执行。
select type：查询类型，SIMPLE（简单查询）、PRIMARY（主查询）、UNION（UNION之后的）、
SUBQUERY（where中包含子查询）
table: 哪张表
prossible_key：可能用到的索引
key: 肯定用到的索引
type: 关联类型 system > const > eq_ref > ref > range > index > all
key_len: 索引长度
rows: 查询的行数
filtered：返回行占读取行的百分比
```

29. 如何对进行分页查询优化？

```
从两个维度来说：
1. 如果表数据超过了2千万就应该要分表分库
2. 如果表数据正常情况，针对于比较大的页时，可以通过利用主键索引来优化
    首先要找到分页数据的第一条数据的id，然后再原本的条件中增加这个id>=xxx的搜索条件，
```

30. hash索引的优缺点

```
hash索引是通过hash函数为字段创建紧凑的数据索引
优点：
1. 数据紧凑，等值查询很快
缺点：
1. hash索引只包含哈希值以及行指针，索引无法避免再次根据行指针去查找行数据
2. hash索引只适合等值查询
3. hash索引无法排序
```

31. InnoDB日志相关的参数是否有了解？

```
1. 日志缓冲池大小调整，一般日志缓冲区的大小为16M,一般是够用的，但如果有blog/text等
大字段就会很快被填满，可以调整日志缓冲区大小
    innodb_log_buffer_size：日志缓冲区大小
    innodb_log_files_in_group:日志文件组个数
    innodb_log_file_size:日志文件大小
2. 如何调优：1小时日志承载量来设置innodb_log_file_size的大小
```
