1. 分布式幂等性如何设计？

```
幂等的概念：
一般指方法被多次重复执行所产生的影响和多次执行产生的影响是相同的。
数据库中查和删是没有幂等问题，增和改存在幂等问题。
导致接口被重复调用的场景：
1. 因为用户的重复提交或恶意攻击导致的请求被重复执行
2. 分布式架构中重试机制导致的多次被执行
如何解决：
1. 可以使用数据库的唯一约束去解决幂等性，比如创建订单，订单号肯定是唯一的，设置订单号是
唯一索引，避免一次请求创建多个订单。
2. 使用redis中提供的setnx，针对MQ队列重复消费的场景，一个队列被执行后将这个消息通过
setNx设置到redis中，第二次消费的时候就不会有问题了。
3. 悲观锁：for update，这个不建议使用，有可能影响系统的性能。
4. 乐观锁：version字段，查询时得到一个version，更新时根据这个状态去更新，如果发现这个
状态已经变了，说明已经被人更新过了，则舍弃这个更新操作。
解决思路：
1. 保证只执行一次方法
2. 保证对数据的影响只触发一次
```

2. 如何理解分布式事务？

```
1. ACID：原子性、一致性、隔离性、持久性
2. CAP：C（一致性），A（可用性）、P（分区容忍性），一般来说满足CP或AP。
3. BASE：最终一致性
解决方案：
1. seata中间件（两阶段）
2. 消息队列（最终一致性）
3. 补偿事务（tcc）
```

3. 如何利用补偿型事务处理分布式事务？

```
什么是补偿事务（TCC）
TCC实际上就是采用补偿机制，其核心思想是针对每个操作，都注册一个对应的确认和补偿操作

补偿事务的步骤：
1. Try阶段主要是对业务系统做检测和资源预留
2. confirm阶段主要是对业务进行确认。
3. cancel阶段是在业务执行异常后，需要对业务进行取消回滚。

适合的场景：
1. 业务要求及时性，对敏感性数据这样处理，比如增加货款。

优势：
1. 保证了最终一致性
劣势：
1. 业务耦合度较高，会提高开发成本。
```

4. 如何利用消息队列和事件表处理分布式事务？

```
1. A服务和B服务，A服务将业务处理之后，往事件表中插入一条事件，然后提交返回给用户
2. A服务中有一个定时器将事件查询出来推送到队列，然后修改状态为已发送
3. 队列消费后更新事件表的状态，如果成功则更新成成功
4. 对于没成功的通过重试就好了
```

5. 分布式ID生成有哪几种方案？

```
分布式ID的特性：
1. 唯一性
2. 高可用性

解决方案：
1. UUID：核心算法是依赖机器的网卡、当地时间、一个随机数来生成UUID
2. 数据库自增ID：绝对唯一，如果是两台服务器需要设置不同的步长
3. redis生成：incr，incrby
4. Twriter的雪花算法：根据时间戳+机器ID+序列号生成
```

4. 常见的负载均衡算法？

```
1. 轮询负载均衡算法
2. 加权轮询算法 -> 平滑加权轮算算法
3. 随机算法
4. 最少连接（哪个服务器链接少就请求），哪个连接少就向谁发请求
5. 原地址散列：根据请求的ip做hash计算，只要ip不变，那就会访问同一个服务器，有利于做
session信息的维护。
```

5. 常见的限流算法有哪些？

```
1. 计算器(固定窗口)算法
    具体实现：
    通过redis的incr，比如说1分钟限流100个流量，那么第一个进来设置set key 1 ttl 60，
然后第二个流量进来incr加1，如果1分钟内incr超过了100，那么就出发限流策略。
    问题：
    临界问题，限流不够均匀，如果说1分钟内，前50秒来了10个流量，第50秒来了50个流量，第
二分钟前10秒来了60个流量，那么在短短的20秒内就来了110个流量，就没达到效果。
2. 滑动时间窗口算法
    是为了解决固定窗口临界问题，意思是将1分钟粒度缩小，比如1分钟分为1-15,16-30,31-45，
46-60，每个区间只能承载25个流量，然后按照上面的算法设置set key 1 ttl 15，颗粒度越小，
限流越均衡。
3. 漏桶算法
    漏桶算法是有一个恒定的漏桶，比如50个容量的漏桶，有一个恒定的流出速率，比如5/s，
流量进来之后先放入漏桶中，如果超过了漏桶的容量则直接不进入漏桶，达到限流效果。
4. 令牌桶算法
    具体实现：
    有一个定时器往一个固定容器（10个）按照恒定的速率（比如100毫秒）往令牌桶中写入令牌，
如果容器中多余10个就抛弃，当请求进来之后需要先获取令牌，有令牌再放行，令牌不足则触发限流
```

```php
// 漏桶算法实现
public function actionTestLeaky()
    {
        for ($i=0;$i<500;$i++){
            $res = $this->leaky(50, 1, 5, $water, $preTime);
            var_dump($res);
            usleep(5000);
        }
    }

    public function leaky($contain, $addNum, $leakRate, &$water=0, &$preTime=0)
    {
        // 首次进入默认当前水量为0
        $water = empty($water) ? 0 : $water;
        // 首次进入默认上次漏水时间为当前时间
        $preTime = empty($water) ? time() : $preTime;
        // 当前时间
        $curTime = time();
        // 上次结束到本次开始流出的水
        $leakWater = ($curTime - $preTime) * $leakRate;
        // 上次的剩余水量 - 中途流出的水量 = 剩余的水量
        $water = $water - $leakWater;
        $water = ($water > 0) ? $water : 0;
        $preTime = $curTime;
        if ($water + $addNum > $contain) {
            // 如果加入的量大于容量则不能进入漏斗
            return false;
        } else {
            $water = $water + $addNum;
            return true;
        }
    }
```

6. 如何处理大数据量？

```
1. 分区
2. 分库分表
     水平拆分：数据量不同
     垂直拆分：数据量相同
3. 主从架构
    主机负责写，从机负责读
```

7. 什么是CAP定理？

```
CAP定理又叫布鲁尔定理，是指在分布式系统中，最多只能同时满足一致性、可用性和分区容错性
这三项中的两项，要么是CP、要么是AP。
C：一致性，意思是指数据在多个副本中是一致的，可以理解为两个用户访问两个系统A和B，A中的数据
变化之后会同步给B，让两个用户看到的数据是一致的。
A：可用性，意思是系统在任何时间访问服务都是可用的。
P：分区容错性，意思是在分布式系统中，由于网络故障导致原本的整个节点环境被分成几个独立的区域，
这就是网络分区。

P必须满足：如果两个分布式系统中，两个服务的数据不能互通，那么就不能称之为分布式系统，所以
P一定要满足
CP：满足一致性，意思就是数据在A服务修改了之后同步给B服务，在同步好之前，B服务是不能对
外提供服务，以此来保证一致性。
AP：满足可用性，意思就是数据在A服务修改了之后同步给B服务，在同步好之前，B依然要提供服务，
此时满足了可用性。

zookeeper用来保证CP。
```

8. 什么是BASE理论？

```
由于在CAP定理中，没办法同时满足C和A，ebay的架构师提出了BASE理论，他通过牺牲数据的强
一致性来获得可用性
Basically Available(基本可用)：在分布式系统在出现不可预知故障的时候，允许损失部分可用，
保证核心功能的可用。
Soft Status（软状态）：是指允许数据存在中间状态，并认为该中间态的存在不会影响系统的整体
可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。
Eventually consistent（最终一致性）：需要系统保证数据的最终一致性，而不需要实时的保证
强一致性。

BASE理论实际中有这样的场景，采用第三方支付的情况，当调用第三方支付支付成功后，状态都是通过
异步回调的方式，此时设置一个正在支付的状态，等待支付回调成功之后修改订单状态，最终让支付变
成已支付。
```

9. 什么是可靠消息最终一致性方案？

```
可靠消息最终一致性方案是保证最终一致性的解决方案，允许数据在业务中短暂的出现数据不一致的
状态。
强调两点：1.可靠消息：发起方一定要把消息传递给消费者；2.最终一致性：最终发起方和消费者处
理一定要完整，保证一致性。

需要解决的问题：
1. 保证事务发起方本地事务和发消息之间的原子性
begin transition;
操作数据库；
发送消息；
commit transition;
这样的顺序写，当数据库操作失败，回滚，消息不会发送，当数据库操作成功，消息发送失败，也可以
进行回滚。
但有一个问题就是发送消息响应超时，数据库操作回滚，但消息最后发送成功了，这时就没办法保证
原子性，需要人工补偿。
2. 保证事务消费方和消息接收之间的原子性
必须保证消费方要接收到消息，由于故障导致导致未接收到消息，需要有消息重发机制；
消费成功后，没有ACK，导致重复消费问题，可以使用保证幂等性来解决。
```

10. 微服务注册中心如何设计？

```
为什么需要微服务注册中心？
服务太多，无法管理，
什么是微服务注册中心？
服务注册中心就是用来管理服务的ip、端口以及其他配置的，比如说哪些有3个服务，在向A服务发起
请求时需要向注册中心获取A服务可用的IP、端口。

如何设计微服务注册中心，应该写哪些接口？
1. 接收服务注册接口：当服务启动后需要向服务注册中心注册。
2. 接收服务心跳接口：服务定时向注册中心发送心跳，如果长时间未接收到心跳则下线该服务。
3. 服务下线接口：当服务下线后，通知注册中心下线。
4. 服务剔除接口：服务挂了没有收到心跳，剔除服务。
5. 查询注册表接口：当要发起请求时，客户端要查询服务的具体信息。
6. 注册中心集群同步接口：一般微服务中都要避免单点故障，注册中心也要做集群，所以集群中的
注册中心要实现同步。
```

11. 谈谈对restful风格的理解？

```
restful是资源表现层状态转移的意思，它是一种风格。
比如:
/book：是一个资源
通过GET、POST、PUT、DELETE状态来达标查、增、改、删

使用Restful最核心的应该是对资源的抽象。
```

12. 微服务设计一般遵循什么原则？

```
1. 单一职责原则。让每个服务独立、有界限的工作，做到高内聚，服务与服务之间做到低耦合
2. 服务自治原则。每个服务可以独立开发、独立测试、独立部署、独立运行。
3. 轻量级通信原则。减少没必要的服务与服务之间的通信，采用消息队列、Restful风格通信。
4. 粒度进化原则。一开始肯定没办法设计得非常好，需要根据业务进化而来的。
```

13. 如何处理超时订单？

```
1. 延时队列，将订单推入支持延时队列的队列中，轮询读取数据
2. RocketMQ，定时消息队列，RocketMQ在服务端起一个定时器
3. 开启redis的过期监听，不可靠
4. 定时任务，稳定性，采用批量处理
```
