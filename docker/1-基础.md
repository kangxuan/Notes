# Docker为什么出现

**以前**

- 开发人员在本地环境中开发，提交的只有代码，运维在部署后发现因为环境不一致跑不起来。

- 即使开发给出了环境清单，但遇到多台集群时，一旦一台环境有问题，运维排错工作量会直线上升。

- 遇到压力增大，没办法秒级别进行扩容，因为要安装各种东西。

- 环境配置很麻烦，换一台机器就要重新配置一次。

**现在**

- 将源码+配置+环境+版本打成一个镜像，直接移植到服务器，这样保证了各台服务器上都是相同的东西，就不会有以前的问题。

- 通过容器虚拟化技术达到系统平滑移植，也就是Docker。

**Docker的理念**

Docker就是将所有各种东西都打包成一个镜像，复制到各个地方，保证项目的正常运行。

# 虚拟机和容器对比

传统虚拟机是从硬件层面实现虚拟化，也就是说将整个系统所有内容都虚拟化，然后再在系统上运行所需的应用程序；而容器则是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，没有自己的内核，也没有进行硬件虚拟。

**传统虚拟机的缺点**

- 资源占用多

- 冗余步骤多

- 启动慢

**容器虚拟机的优点**

- 资源占用少

- 启动速度快

# Docker基础概念

**Docker是什么？**

- Docker是基于Go实现的云开源项目。

- Docker的目标是"Build、Ship and Run Any APP，AnyWhere"，就是通过对应用软件的封装、分发、部署、运行等生命周期的管理，让APP以及其运行环境能够做到“一次镜像、处处运行”。

- `Docker`提供了一种叫`容器`的隔离环境，来运行应用程序的功能。可以在指定的主机同时运行多个容器。占用的内存和资源较少，它是安全的，因为容器是相互隔离。

- 解决了运行环境和配置问题的软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。

**Docker的用途**

- 提供一次性环境

- 提供弹性的云服务

- 组建微服务架构

**Docker引擎**

`Docker引擎`是一个包含以下组件的客户端服务器应用程序。

- `server docker daemon`：一个守护进程，会一直跑在Docker主机上。
- `REST API`：REST API用于指定程序可以用来与守护进程通信的接口，并指示其做什么。
- `Client docker CLI`：一个有命令行界面的客户端。

**Docker架构**

其架构主要分为三部分

- 客户端（Client）：Docker提供命令行界面工具来进行和Docker守护进程交互。客户端可以构建、运行和停止应用程序。客户端还可以远程和Docker_Host进行交互。
- 服务端（Docker_Host）：包含容器、映像和Docker守护进程。提供了完整的环境来执行和运行应用程序。
- 注册表（Registry）：全局映像库，可以访问并使用这些映像在docker环境中运行这些应用程序。

Docker是一个Client-Server架构系统，Docker守护进程运行在主机上，通过Socket连接从客户端访问，守护进程从客户端接收命令并管理主机上的容器。

**Docker的运行流程**

1. 用户通过`Docker Client`连接`Docker Server`建立通信， 并发送请求。

2. `Docker Daemon`作为Docker架构的主体，提供了`Docker Server`可以连接`Docker Client`的请求。

3. `Docker Engine`执行Docker内部的一系列工作，每一项工作都是以一个`Job`的形式存在。

4. `Job`在运行过程中，当需要容器镜像时，则通过`Docker Registry`中下载镜像，并通过镜像管理驱动`Graph driver`将下载的镜像以`Graph`形式存储。

5. 当需要为Docker创建网路环境时，通过网络管理驱动`Network driver`创建并配置Docker容器的网络环境。

6. 当需要限制Docker容器运行资源或执行用户指令的操作时，则通过`Exec driver`来完成。

7. `Libcontainer`是一项独立的容器管理包，`Network driver`以及`Exec driver`都是通过`Libcontainer`来实现对容器的操作。

**Docker基本组成**

- `Docker image`：
  - 镜像。
  - 镜像是一个只读的模板。
  - 镜像是用来创建容器（`container`），是`Docker container`的设计蓝图，一个镜像可以创建多个容器。
  - `Docker image`可以通过`Dockerfile`创建，也可以在Docker hub/registry上下载。
  - `Docker image`包括`Dockerfile`、依赖和程序的代码。
  - `Dockerfile`文件中包含了一系列的指令来创建`Docker image`。
- `Docker container`：
  - 容器。
  - 容器是镜像创建出来的运行实例，多个容器是相互隔离的，保证运行在容器中的程序运行在一个安全的环境中，就是鲸鱼背上的集装箱。
  - 容器是一个简易版的Linux环境，底层是最小最核心赖以生存的Linux内核文件，不需要的不加载，上层是运行的应用程序。
- `Docker hub/registry`：
  - 共享和管理docker镜像的仓库，用户可以往上面上传或从上面下载镜像。
  - 全球最大的公有库是[Docker hub官网](https://hub.docker.com/)

# Docker安装

不同系统的Docker安装包都可以从官网下载得到，[Docker官网](https://www.docker.com/)

**Linux安装**

[Install Docker Engine on CentOS | Docker Documentation](https://docs.docker.com/engine/install/centos/)

`yum`安装

```shell
yum install docker
```

启动Docker

```shell
service docker start

# Redirecting to /bin/systemctl start  docker.service
```

设置开机自启动

```shell
chkconfig docker on
```

**MacOS安装**

安装即可会得到客户端

# 尝试第一个Docker制作过程

以go为例，先编写一个go例子

```go
// filename:floot_type_view.go
package main

import "fmt"

func reverseWithGenerics[T any](s []T) []T {
    l := len(s)
    r := make([]T, l)

    for i, e := range s {
        r[l-i-1] = e
    }
    return r
}

func main() {
    fmt.Println(reverseWithGenerics[int]([]int{1, 2, 3, 4}))
    fmt.Println(reverseWithGenerics[float64]([]float64{0.1, 0.2, 0.3, 0.4}))
}
```

编译一个go可执行文件

```shell
# 将floot_type_view.go编译成一个名为floot_type_view-app的可执行文件
# 注意目标机器的系统
go build -o floot_type_view-app floot_type_view.go
```

编写Dockerfile

```dockerfile
# 导入官方go对应的版本
FROM golang:1.19.3

# 将当前目录下的所有文件（除了.dockerignore排除的路径或文件），都拷贝到 image 文件的 /app 目录里面
COPY . /app

# 指定工作目录为/app
WORKDIR /app

# 将可执行文件添加到工作目录下
ADD floot_type_view-app $WORKDIR/

# 运行go程序
CMD /app/floot_type_view-app
```

制作Docker  image

```shell
# 根据当前目录下的Dockerfile制作Docker image
docker image build -t floot_type_view-app .
# 或
docker build -t floot_type_view-app .
```

查看images

```shell
docker image ls
# 或
docker images
```

运行容器

```shell
docker container run floot_type_view-app
# 或
docker run floot_type_view-app

# 结果
[4 3 2 1]
[0.4 0.3 0.2 0.1]
```

# Docker基础操作

**查看Docker信息**

```shell
docker info
```

**查看Docker版本**

```shell
docker version
```

**修改镜像地址**

官网服务器在国外，可设置中国官方镜像

- docker中国镜像：[registry.docker-cn.com](http://registry.docker-cn.com)

- 阿里云镜像：[阿里巴巴开源镜像站-OPSX镜像站-阿里云开发者社区](https://developer.aliyun.com/mirror/)

修改Docker配置

```shell
# 编辑配置
cd /etc/docker
vim *.json
```

增加如下代码

```json
{                                                                                                                                
    "registry-mirrors": ["https://registry.docker-cn.com"],                                                                      
    "live-restore": true                                                                                                         
}
```

# 镜像操作

**搜索镜像**

```shell
docker search centos
```

结果：

```log
NAME                                         DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
centos                                       The official build of CentOS.                   7158                [OK]                
centos/systemd                               systemd enabled base container.                 108                                     [OK]
centos/mysql-57-centos7                      MySQL 5.7 SQL database server                   94                                      
centos/postgresql-96-centos7                 PostgreSQL is an advanced Object-Relational …   45                                      

NAME：镜像名称
DESCRIPTION：镜像描述
STARS：用户评价，反应一个镜像的受欢迎程度
OFFICIAL：是否是官方镜像
AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的
```

**拉取镜像**

从远程仓库拉取镜像到本地

```shell
docker pull library/hello-world
```

**查看本地镜像**

```shell
docker images

# 或

docker image ls
```

**删除本地镜像**

```shell
docker rmi docker.io/hello-world
```

# 容器操作

**创建并启动容器**

- 交互式容器
  
  创建启动容器后，直接进入容器（即分配一个伪终端）。exit退出容器后，容器停止工作。

```shell
docker run -it --name=mycentos centos:7 /bin/bash
```

- 守护式容器
  
  以形成一个后台守护进程，针对于需要长期运行的服务容器。

```shell
docker run -id --name=mycentos centos:7 /bin/bash
```

docker run 参数解析

| 参数     | 解释                                          |
| ------ | ------------------------------------------- |
| -i     | 表示运行容器                                      |
| -t     | 表示创建运行容器后直接进入                               |
| --name | 表示容器名称，容器名称不能重复                             |
| -d     | 表示创建启动一个守护式容器                               |
| -p     | 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 |
| -v     | 表示目录映射                                      |

**查看容器**

- 查看运行中的容器列表

```shell
docker ps
```

- 查看所有的容器列表

```shell
docker ps -a
```

**启动和停止容器**

- 启动已有容器

```shell
docker start <container_name>/<container_id> # 容器名或容器ID
```

- 停止容器运行

```shell
docker stop <container_name>/<container_id>
```

- 重启容器

```shell
docker restart <container_name>/<container_id>
```

**文件拷贝**

- 将宿主机的文件拷贝到容器内

```shell
# docker cp 文件路径 容器名称:容器内目录
docker cp abc.txt <container_name>:/
```

- 将容器内文件拷贝到宿主机

```shell
# docker cp 容器名称:文件路径 宿主机目录
docker cp <container_name>:/cba.txt 
```

*注意：容器在停止状态下也可以cp*

**进入容器**

```shell
docker exec -it <container_name> /bin/bash
```

**删除容器**

```shell
docker rm <container_name>/<container_id>
```

**挂载目录**

创建容器时，可以将宿主机中的一个目录映射到容器内的一个目录，这样修改了宿主机中的文件就相当于修改了容器中的文件。

可以代码开发文件放在宿主机，运行环境放在容器中。

```shell
docker -id -v 宿主机目录:容器内目录 --name=容器名称 镜像名称:TAG
docker -id -v ~/workspace:/www --name=mycentos2 centos:7

# 这样在宿主机workspace下开发，就直接可以运行调试了。
```

**查看容器内容**

```shell
docker inspect <container_name>
```
