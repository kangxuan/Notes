# Mysql架构图

<img title="" src="./images/Mysql架构图.png" alt="Mysql架构图" width="458">

Mysql由Server层和存储引擎层两部分组成。

# Server层

Server层主要包括连接器、缓存查询、分析器、优化器、执行器等，涵盖了大部分Mysql核心的服务功能，以及所有的内置函数（比如日期、时间、数学等），所有跨存储引擎的功能都在Server层实现，比如存储过程、触发器、视图等。

### 连接器

客服端连接Mysql第一步就是和连接器交互，连接器负责和客服端建立连接、获取权限、维持和管理连接。

```shell
mysql -h$ip -P$port -u$user -p
```

输入命令后，连接器开始工作，先验证身份，如果身份认证成功后会从权限表中读取用户的权限，后续的操作都依赖此时读取的权限，所以后续管理员对用户的权限进行调整也不会生效，而是等重新连接后才会生效。

如果建立连接后，没有后续的操作，连接会进入sleep状态。如果太长时间没有操作，连接器会自动断开连接，根据`wait_timeout`控制，默认为8小时。

连接分为长连接和短连接、长连接是指在建立连接后，如果客服端有持续的请求，会一直使用一个连接，与之对应的是短连接，每次查询几次后就会断开连接，下次查询会重新创建新连接。短连接是不推荐的，因为每次建立连接会非常复杂，但使用长连接会导致Mysql占用内存会涨得很快，可能会被系统kill掉。

处理长连接占用内容的方法：

1. 定期断开长连接，使用一段时间后或者执行一个占用内容较大的查询后断开连接。

2. 如果使用5.7或之后的版本，可以使用`mysql_reset_connection`来初始化连接资源，此操作不需要重新连接，但会释放资源。

### 缓存查询

建立连接后，会先进行缓存查询，如果缓存中存在数据则直接返回，这样效率很高。

但对于更新频繁的表就不要使用缓存查询，因为缓存频繁更新会命中率很低，缓存存储费力不讨好。

缓存查询通过参数`query_cache_type`开启，但实际场景中不可能开启所有查询走缓存，所以提供了按需查询的方法：

```sql
select SQL_CACHE * from T where ID=10;
```

注意：在Mysql8.0之后缓存查询这块的功能都被拿掉了。

### 分析器

缓存查询未命中，会进入分析器对执行语句进行分析，主要包括词法分析、表名、字段名进行验证等。如果查询的字段不存在也会在分析器阶段暴露出来。

### 优化器

经过分析器之后，语法错误被排除，知道要做什么事，但在执行之前，会先对SQL进行优化，如何选择索引、如何更优搜索都在优化器阶段。

### 执行器

经过优化器之后开始执行语句，在执行之前要先判断对表是否有相应的权限。

# 存储引擎

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。

### MySQL支持的存储引擎

```sql
# 查看MySQL支持的存储引擎
mysql> show engines;
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
```

### 创建时指定存储引擎，否则默认为InnoDB

```sql
-- 创建一个MyISAM引擎的表
create table my_myisam (
    id int,
    name varchar(10)
) engine = MyISAM;

-- 创建一个Memory引擎的表
create table my_memory (
    id int,
    name varchar(10)
) engine = Memory;
```

### InnoDB

InnoDB是一种兼顾高可用和高性能的存储引擎，MySQL5.5后默认使用InnoDB。

**特点**

- 支持事务，DML操作遵循ACID模型

- 行级锁，提高并发访问性能

- 外键，保证数据的完整性和正确性

**存储**

- 以`.idb`文件保存每张表的结构、数据和索引。

- 开启了`innodb_file_per_table`参数则每张表保存一个文件，否则采用压缩方式。

```sql
# 查看innodb是否每张表存储一个文件
mysql> show variables like 'innodb_file_per_table';
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| innodb_file_per_table | ON    |
+-----------------------+-------+
```

**逻辑存储结构**

- 表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。

- 段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。

- 区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。

- 页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。

- 行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段。

### MyISAM

MySQL最初默认的存储引擎。

**特点**

- 不支持事务、不支持外键

- 表锁

- 访问速度快

**存储**

- `.sdi`文件存储表结构信息

- `.MYD`存储数据

- `.MYI`存储索引

### Memory

Memory的表数据存储在内存中，表结构存储在磁盘，所以是不安全的。

**特点**

- 内存存放访问速度快。

**存储**

- `.sdi`存储表结构信息

- 数据存储在内存中

### 三种存储引擎的区别

| 特点       | InnoDB | MyISAM | Memory |
| -------- | ------ | ------ | ------ |
| 存储限制     | 64TB   | 有      | 有      |
| 事务安全     | 支持     | 不支持    | 不支持    |
| 锁机制      | 行锁     | 表锁     | 表锁     |
| B+tree索引 | 支持     | 支持     | 支持     |
| Hash索引   | 不支持    | 不支持    | 支持     |
| 全文索引     | 支持     | 支持     | 不支持    |
| 空间使用     | 高      | 低      | 很低     |
| 内存使用     | 高      | 低      | 中等     |
| 批量插入速度   | 低      | 高      | 高      |
| 支持外键     | 支持     | 不支持    | 不支持    |

### 存储引擎的选择

**InnoDB:**  是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。

**MyISAM ：** 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。

**MEMORY：** 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。
