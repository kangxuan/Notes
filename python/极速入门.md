# 前言

本文是针对有基础的程序员，至少掌握一门计算机语言，帮助能够快速掌握python基础。此文档是基于python3的。

# 语法类

### 运算相关

##### 1、除法的结果是自动转换为浮点数

即使两个整数能整除，其结果也会自动转换为浮点数

```python
35 / 5  # => 7.0
10.0 / 3  # => 3.3333333333333335
```

##### 2、除法取整的结果都是向下取整

`//`是除法取整的写法，其结果会向下取整，整数和整数相除其结果是整数，但任意是浮点数其结果一定是浮点数

```python
5 // 3       # => 1
5.0 // 3.0   # => 1.0
-5 // 3      # => -2
-5.0 // 3.0  # => -2.0
5 // 3.0     # => 1.0
5.0 // -3    # => -2.0
```

##### 3、取模的结果符号和除数一致

i % j 结果的正负符号会和 j 相同，而不是和 i 相同

```python
7 % 3  # => 1
# i % j 结果的正负符号会和 j 相同，而不是和 i 相同
-7 % 3  # => 2
7 % -3  # => -2
-7 % -3  # => -1
5.0 % 3  # => 2.0
-5.0 % 3.0  # => 1.0
```

##### 4、x的y次方

```python
2 ** 3 # => 8
2 ** -3  # => 0.125 2的-3次方=1/(2**3)
-2 ** 3  # => -8
-2 ** -3  # => -0.125
```

##### 5、bool运算

使用`not`取非

```python
not False # => True
not True # => Flase
```

使用`and`和`or`用来求并和求或

```python
True and False # => False
False or True # => True
```

本质上`True`和`False就是数字1和0，所以bool值也可以进行运算

```python
True + True # => 2
True * 8    # => 8
False - 5   # => -5
```

`数值和bool类型比较，把True当做1，False当做0

```python
0 == False # => True
2 == True # => False
1 == True # => True
-5 != False # => True
```

None`，`0`，`空字符串，空列表，空字典，空元组都算是 False，其他所有值都是True。

```python
bool(0)  # => False
bool("")  # => False
bool([]) # => False
bool({}) # => False
bool(()) # => False
```

##### 6、比较运算符可以连着写好多个

```python
1 < 2 < 3 # => True
1 < 2 > 3 # => False
```

##### 7、==是判断两个对象是否含有相同的值，is是判断是否引用同一个对象

```python
a = [1, 2, 3, 4]  # 变量 a 是一个新的列表, [1, 2, 3, 4]
b = a             # 变量 b 赋值了变量 a 的值
b is a            # => True, a 和 b 引用的是同一个对象
b == a            # => True, a 和 b 的对象的值相同
b = [1, 2, 3, 4]  # 变量 b 赋值了一个新的列表, [1, 2, 3, 4]
b is a            # => False, a 和 b 引用的不是同一个对象
b == a            # => True, a 和 b 的对象的值相同
```

##### 8、可以通过if else实现三目运算

类似php的`? : `

```python
print("yay!" if 0 > 1 else "nay!") # => nay!
print("yay!" if 0 < 1 else "nay!") # => yay!
```

### 字符串相关

##### 1、字符串可以用单引号也可以用双引号

单引号和双引号效果一致

```python
a = 1
print("Hello World!") # => Hello World!
print('Hello World!') # => Hello World!
print(f'Hello World!{a}') # => Hello World!1
print(f"Hello World!{a+1}") # => Hello World!2
```

##### 2、字符串连接通过+号连接

一般通过`+`号连接，甚至可以搞个空格符也行

```python
print("Hello" + "World!") # => HelloWorld!
print("Hello" "World!") # => Hello World!
```

##### 3、字符串可以被当作字符列表

字符串无需显式赋值给变量，也可以直接通过列表形式取出某个字符

```python
print("Hello World!"[0]) # => H
print("你好"[1]) # => 好
```

##### 4、通过.format来格式化字符串

```python
# 通过.format()方法格式化字符串
print("{} can be {}".format("strings", "interpolated"))
# => strings can be interpolated
# 可以重复参数以节省时间
print("{0} be nimble, {0} be quick, {0} jump over the {1}".format("Jack", "candle stick"))
# => Jack be nimble, Jack be quick, Jack jump over the candle stick
# 如果不想数参数，可以用关键字
print("{name} wants to eat {food}".format(name="Bob", food="lasagna"))
# => Bob wants to eat lasagna
```

##### 5、Print默认会带一个换行符，也可以通过end参数定义

```python
print("sadfasdf", end="") # 不会换行
print("asdfasdf") # 会换行
print("asdfasdf", end="!") # 不会换行
```

##### 6、通过input获取命令行输入

```python
input_string_var = input("Enter some data: ")
print(input_string_var) # 会输出用户在命令行输入的内容
```

### list的骚操作

列表（list）可以理解为不定长数组，和php中的数组一样。

##### 1、列表声明

通过`[]`声明一个空列表，也可以初始化一些数据

```python
# 用列表 (list) 储存序列
li = []
# 创建列表时也可以同时赋给元素
other_li = [4, 5, 6]
```

##### 2、列表的append和pop

append向后追加元素，pop出最后一个元素

```python
li.append(1)    # li现在是[1]
li.append(2)    # li现在是[1, 2]
li.append(4)    # li现在是[1, 2, 4]
li.append(3)    # li现在是[1, 2, 4, 3]
# 用pop从列表尾部删除
li.pop()        # => 3 且li现在是[1, 2, 4]
# 把3再放回去
li.append(3)    # li变回[1, 2, 4, 3]
```

##### 3、列表的切割语法

```python
# 从下标1到下标3，不包括下标3
li[1:3]    # => [2, 4]
# 取尾，从下标2开始到末尾
li[2:]     # => [4, 3]
# 取头，从开头到下标3（不包括3）
li[:3]     # => [1, 2, 4]
# 隔一个取一个
li[::2]    # =>[1, 4]
# 倒排列表
li[::-1]   # => [3, 4, 2, 1]

# 可以用三个参数的任何组合来构建切割
# li[始:终:步伐]
li[1:3:2] # => [2]
```

##### 4、list复制

```python
li2 = li[:]  # => li2 = [1, 2, 4, 3] ，但 (li2 is li) 会返回 False
```

##### 5、删除和插入元素

```python
# 删除索引1到索引3（不包括3）的所有元素
del list[1:3]
print(list) # => [1, 3]

# 删除匹配元素
list.remove(3)
print(list) # => [1]

# 插入元素到索引1
list.insert(1, 2)
print(list) # => [1, 2]
list.insert(2, 4)
print(list) # => [1, 2, 4]
list.insert(3, 3)
print(list) # => [1, 2, 4, 3]
```

##### 6、合并列表

```python
list.extend([5, 6, 7]) # => [1, 2, 4, 3, 5, 6, 7]
other_list = [8, 9, 10]
list + other_list # => [1, 2, 4, 3, 5, 6, 7, 8, 9, 10]
```

##### 7、元素可以是任意数据类型

```python
list1 = [1, 2, 3, "a", "b", "c"]
```

### tuple

元组（tuple）则是一个定长数组，不允许修改。

```python
# 定义元组
tup = (1, 2, 3)
print(tup) # => (1, 2, 3)

# 不允许修改元组的元素
tup[0] = 3 # => TypeError: 'tuple' object does not support item assignment
```

##### 1、元素数量为1的元组必须在元素之后加一个逗号

元素数量为1如果不加逗号，会被当做这个元素被括起来，求其类型。

```python
type((1))   # => <class 'int'>
type((1,))  # => <class 'tuple'>
type(())    # => <class 'tuple'>

type(("hello")) # => <class 'str'>
type(("hello",)) # => <class 'tuple'>
```

##### 2、列表大多数操作都可以运用到元组

除了append、pop、del、remove对元组进行改变的操作不行。

```python
("hello",)[0] # => hello
tup + (4, 5, 6) # => (1, 2, 3, 4, 5, 6)
tup[:2]   # => (1, 2)
if 1 in tup:
    print("1 is in tup") # => 1 is in tup

# 操作
#del tup[0] # => TypeError: 'tuple' object doesn't support item deletion
#tup.remove(2) # => ValueError: tuple.remove(x): x not in tuple
#tup.append(3) # => AttributeError: 'tuple' object has no attribute 'append'
#tup.pop() # => TypeError: 'tuple' object doesn't support item deletion
```

##### 3、元组可以用来解包赋值

```python
# 可以把元组合列表解包，赋值给变量
a, b, c = (1, 2, 3)     # 现在 a 是 1，b 是 2，c 是 3
# 也可以做扩展解包
a, *b, c = (1, 2, 3, 4)  # 现在 a 是 1, b 是 [2, 3]， c 是 4
# 元组周围的括号是可以省略的
d, e, f = 4, 5, 6 # 元组 4, 5, 6 通过解包被赋值给变量 d, e, f
# 交换两个变量的值就这么简单
e, d = d, e     # 现在 d 是 5，e 是 4
print(a, b, c, d, e, f) # => 1 [2, 3] 4 5 6
```

### dict

字典（dict）用来存储 key 到 value 的映射关系，对应golang中的map。

```python
# 定义空字典
empty_dict = {} # => {}
# 初始化空字典
filled_dict = {"a": 1, "b": 2, "c": 3} # => {"a": 1, "b": 2, "c": 3}
```

##### 1、字典的key必须是不变类型

字典的 key 必须为不可变类型。 这是为了确保 key 被转换为唯一的哈希值以用于快速查询。不可变类型包括整数、浮点、字符串、元组。

```python
# 列表是可变的，所以是无效的key
invalid_dict = {[1,2,3]: "123"}  # => 抛出 TypeError: unhashable type: 'list'
# 元组是不可变的，所以是有效的key
valid_dict = {(1,2,3):[1,2,3]} # => {(1, 2, 3): [1, 2, 3]}
```

##### 2、取keys和values

```python
# 取keys
list(filled_dict.keys()) # => ['a', 'b', 'c']
list(valid_dict.keys()) # => [(1, 2, 3)]

# 取values
list(filled_dict.values()) # => [1, 2, 3]
list(valid_dict.values()) # => [[1, 2, 3]]
```

##### 3、通过get安全获取字典值

通过下标形式容易产生异常报错，但通过get方法可以安全获取，如果不存在的key，会返回None。如果key不存在还可以默认值。

```python
filled_dict.get("d") # => None
filled_dict.get("e", 0) # => 0
```

##### 4、字典操作

```python
# setdefault 方法用于获取指定 key 对应的值。如果 key 不存在，则设置默认值并返回。
filled_dict.setdefault("a", 0) # => 1，设置成功
filled_dict.setdefault("d", 0) # => 0，设置失败

# 通过update方法更新字典
filled_dict.update({"d": 4, "e": 5}) # => {"a": 1, "b": 2, "c": 3, "d": 4, "e": 5}

# 通过下标赋值
filled_dict["f"] = 6 # => {"a": 1, "b": 2, "c": 3, "d": 4, "e": 5, "f": 6}

# 删除
del filled_dict["f"] # => {"a": 1, "b": 2, "c": 3, "d": 4, "e": 5}
```

### set

集合（set）是一个无序且不重复的结构。

```python
empty_set = set() # => set()

some_set = {1, 1, 2, 2, 3, 4} # => {1, 2, 3, 4}
```

##### 1、set的value必须是不可变类型

```python
invalid_set = {[1], 1}  # => 抛出 TypeError: unhashable type: 'list'

valid_set = {(1,2,3), 1} # => {(1, 2, 3), 1}
```

##### 2、添加移除元素

向集合中添加元素会进行重复过滤。

```python
# 添加元素
filled_list.add(5) # => {1, 2, 3, 4, 5}
filled_list.add(5) # => {1, 2, 3, 4, 5}

# 移除元素
filled_list.remove(5) # => {1, 2, 3, 4}
```

##### 3、集合的计算

集合常见的计算有求交集、求并集、求差集、异或集（对称差）等。

```python
# 交集
set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}
set1 & set2 # => {3, 4}

# 并集
set1 | set2 # => {1, 2, 3, 4, 5, 6}

# 差集
set1 - set2 # => {1, 2}
set2 - set1 # => {5, 6}

# 对称差集
set1 ^ set2 # => {1, 2, 5, 6}

# 判断左边的集合是否是右边集合的超集
{1, 2} >= {1, 2, 3} # => False

# 判断左边的集合是否是右边集合的子集
{1, 2} <= {1, 2, 3} # => True
```

##### 4、用copy方法进行深度拷贝，拷贝出来的不是同一个对象

```python
filled_set = some_set.copy()  # filled_set 是 {1, 2, 3, 4, 5}
print(filled_set is some_set) # => False
```

### 流程控制

##### 1、if

```python
age = 18

if age > 60:
    print("老年人")
elif age >= 18:
    print("成年人")
else:
    print("未成年人")
# 成年人
```

##### 2、for/while

```python
"""
用 for 循环语句遍历列表
打印:
    dog is a mammal
    cat is a mammal
    mouse is a mammal
"""
for animal in ["dog", "cat", "mouse"]:
    print(f"{animal} is a mammal")

print("-----------------")

"""
"range(number)" 返回数字列表从 0 到 number 的数字
打印:
    0
    1
    2
    3
"""
for number in range(4):
    print(number)

print("-----------------")

"""
"range(lower, upper)" 会返回一个包含从 lower 到 upper 的数字迭代器
prints:
    4
    5
    6
    7
"""
for number in range(4, 8):
    print(number)

print("-----------------")

"""
"range(lower, upper, step)" 会返回一个，从 lower 到 upper、并且间隔值为 step 的迭代器。
如果 step 未传入则会使用默认值 1
prints:
    4
    6
"""
for number in range(4, 8, 2):
    print(number)

print("-----------------")

"""
遍历列表，并且同时返回列表里的每一个元素的索引和数值。
prints:
    0 dog
    1 cat
    2 mouse
"""
for index, animal in enumerate(["dog", "cat", "mouse"]):
    print(f"{index} {animal}")

print("-----------------")

"""
while 循环直到条件不满足
打印:
    0
    1
    2
    3
"""
number = 0
while number < 4:
    print(number)
    number += 1
```

执行结果：

```shell
dog is a mammal
cat is a mammal
mouse is a mammal
-----------------
0
1
2
3
-----------------
4
5
6
7
-----------------
4
6
-----------------
0 dog
1 cat
2 mouse
-----------------
0
1
2
3
```

##### 3、try/except

```python
try:
    # 用 raise 抛出异常
    raise IndexError("This is an index error")
except IndexError as e:
    pass                             # pass 是无操作，但是应该在这里处理错误
except (TypeError, NameError):
    pass                             # 可以同时处理不同类的错误
else:                    # else语句是可选的，必须在所有的except之后
    print("All good!")   # 只有当try运行完没有错误的时候这句才会运行
finally:                                 # 在任何情况下都会执行
     print("We can clean up resources here")
```

使用`with as`替代`try except`：

```python
with open("myfile.txt") as f:
    for line in f:
        print(line)
```

##### 4、iter/next迭代器

Python 提供一个叫做可迭代 (iterable) 的基本抽象。一个可迭代对象是可以被当作序列的对象。比如说上面`range`返回的对象就是可迭代的。

```python
filled_dict = {"one": 1, "two": 2, "three": 3}
our_iterable = filled_dict.keys()
print(our_iterable) # => dict_keys(['one', 'two', 'three'])，是一个实现可迭代接口的对象

# 可迭代对象可以遍历
for i in our_iterable:
    print(i)    # 打印 one, two, three

# 但是不可以随机访问
our_iterable[1]  # 抛出TypeError

# 可迭代对象知道怎么生成迭代器
our_iterator = iter(our_iterable)

# 迭代器是一个可以记住遍历的位置的对象
# 用 "next()" 获得下一个对象
next(our_iterator)  # => "one"

# 再一次调取 "next()" 时会记得位置
next(our_iterator)  # => "two"
next(our_iterator)  # => "three"

# 当迭代器所有元素都取出后，会抛出 StopIteration
next(our_iterator) # 抛出 StopIteration

# 我们还可以通过遍历访问所有的值，实际上，for 内部实现了迭代
our_iterator = iter(our_iterable)
for i in our_iterator:
    print(i)  # 依次打印 one, two, three

# 可以用 list 一次取出迭代器或者可迭代对象所有的元素
list(filled_dict.keys())  # => 返回 ["one", "two", "three"]
list(our_iterator)  # => 返回 [] 因为迭代的位置被保存了
```

### 函数

函数通过关键字`def`定义。

```python
# 函数通过def语句定义
def add(x, y):
    print("x is {} and y is {}".format(x, y))
    return x + y    # 用 return 语句返回

# 调用函数时，传入的参数会被赋值给函数的参数
add(1, 2) # => x is 1 and y is 2

# 也可以用关键字参数来调用函数
add(y=6, x=5) # => x is 5 and y is 6
```

##### 1、定义变参函数

定义可变参数函数：

```python
def varargs(*args):
    for arg in args:
        print(arg)

varargs(1, 2, 3)

# 1
# 2
# 3
```

定义关键字参数函数：

```python
def keyword_args(**kwargs):
    for key in kwargs:
        print("{} is {}".format(key, kwargs[key]))

# 我们来看看结果是什么：
keyword_args(big="foot", loch="ness")

# big is foot
# loch is ness
```

这两种可变参数可以混着用：

```python
def all_the_args(*args, **kwargs):
    print(args)
    print(kwargs)

all_the_args(1, 2, a=3, b=4)

# (1, 2)
# {'a': 3, 'b': 4}
```

##### 2、函数作用域

通过`global`函数将参数的作用域调整到函数内部。

```python
x = 5

def setX(num):
    # 局部作用域的 x 和全局域的 x 是不同的
    x = num # => 43
    print (x) # => 43

def setGlobalX(num):
    global x
    print (x) # => 5
    x = num   # 现在全局域的 x 被赋值
    print (x) # => 6

setX(43)
setGlobalX(6)
```

##### 3、匿名函数

函数中返回函数：

```python
def create_adder(x):
    def adder(y):
        return x + y
    return adder

add_10 = create_adder(10)
print(add_10(3)) # => 13
```

通过`lambda`定义匿名函数：

```python
(lambda x: x > 2)(3)                  # => True
(lambda x, y: x ** 2 + y ** 2)(2, 1)  # => 5
```

##### 4、内置高阶函数

```python
# 内置的高阶函数
print(list(map(add_10, [1, 2, 3])))          # => [11, 12, 13]
print(list(map(max, [1, 2, 3], [4, 2, 1])))  # => [4, 2, 3]

print(list(filter(lambda x: x > 5, [3, 4, 5, 6, 7])))  # => [6, 7]
```

### 导入模块

```python
import math # 导入模块
import math as m # 重命名
from math import ceil, floor # 导入math模块中的ceil和floor函数

print(math.sqrt(9) == m.sqrt(9))  # => True

print(ceil(3.7))   # => 4.0
print(floor(3.7))  # => 3.0
```

### 类

通过`class`定义类：

```python
class Human:
    # 一个类的字段。 这个字段共享给这个类的所有实例。
    species = "H. sapiens"

    # 初始化方法。 当创建一个新的实例时调用。
    def __init__(self, name):
        self.name = name
        self.age = 0

    def say(self, msg):
        print(f"{self.name} says: {msg}")

    # 另一个实例方法
    def sing(self):
        return 'yo... yo... microphone check... one two... one two...'

    # 第一个参数是这个类对象。
    @classmethod
    def get_species(cls):
        return cls.species

    # 静态方法。调用时没有实例或类的绑定。
    @staticmethod
    def grunt():
        return "*grunt*"

    # property 有点类似 getter
    # 它把方法 age() 转换为同名并且只读的属性
    # 通常情况下，可以不需要编写复杂的 getter 和 setter。
    @property
    def age(self):
        return self._age

    # 允许属性被修改
    @age.setter
    def age(self, age):
        self._age = age

    # 允许属性被删除
    @age.deleter
    def age(self):
        del self._age
```

##### 1、类的继承

```python
from Human import Human

class Superhero(Human):
    
    species = 'Superhuman'

    def __init__(self, name, movie=False,
                 superpowers=["super strength", "bulletproofing"]):

        # 新增额外类的参数
        self.fictional = True
        self.movie = movie
        # 注意可变的默认值，因为默认值是共享的
        self.superpowers = superpowers
        # "super" 函数让你可以访问父类中被子类重写的方法
        # 在这个例子中，被重写的是 __init__ 方法
        # 这个语句是用来运行父类的构造函数:
        super().__init__(name)

    # 重写父类的方法
    def sing(self):
        return 'Dun, dun, DUN!'

    def boast(self):
        for power in self.superpowers:
            print("I wield the power of {pow}!".format(pow=power))
```

##### 2、多重继承

同时继承多个类：

```python
class Bat:

    species = 'Baty'

    def __init__(self, can_fly=True):
        self.fly = can_fly

    # 这个类同样有 say 的方法
    def say(self, msg):
        msg = '... ... ...'
        return msg

    # 新增一个独有的方法
    def sonar(self):
        return '))) ... ((('

from superhero import Superhero
from bat import Bat

# 定义 Batman 作为子类，来同时继承 SuperHero 和 Bat
class Batman(Superhero, Bat):

    def __init__(self, *args, **kwargs):
        # 通常要继承属性，你必须调用 super:
        # super(Batman, self).__init__(*args, **kwargs)
        # 然而在这里我们处理的是多重继承，而 super() 只会返回 MRO 列表的下一个基础类。
        # 因此，我们需要显式调用初始类的 __init__
        # *args 和 **kwargs 传递参数时更加清晰整洁，而对于父类而言像是 “剥了一层洋葱”
        Superhero.__init__(self, 'anonymous', movie=True,
                           superpowers=['Wealthy'], *args, **kwargs)
        Bat.__init__(self, *args, can_fly=False, **kwargs)
        # 重写了 name 字段
        self.name = 'Sad Affleck'

    def sing(self):
        return 'nan nan nan nan nan batman!'
```


