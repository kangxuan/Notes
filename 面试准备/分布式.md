1. 分布式幂等性如何设计？

```
幂等的概念：
一般指方法被多次重复执行所产生的影响和多次执行产生的影响是相同的。
数据库中查和删是没有幂等问题，增和改存在幂等问题。
导致接口被重复调用的场景：
1. 因为用户的重复提交或恶意攻击导致的请求被重复执行
2. 分布式架构中重试机制导致的多次被执行
如何解决：
1. 可以使用数据库的唯一约束去解决幂等性，比如创建订单，订单号肯定是唯一的，设置订单号是
唯一索引，避免一次请求创建多个订单。
2. 使用redis中提供的setnx，针对MQ队列重复消费的场景，一个队列被执行后将这个消息通过
setNx设置到redis中，第二次消费的时候就不会有问题了。
3. 悲观锁：for update，这个不建议使用，有可能影响系统的性能。
4. 乐观锁：version字段，查询时得到一个version，更新时根据这个状态去更新，如果发现这个
状态已经变了，说明已经被人更新过了，则舍弃这个更新操作。
解决思路：
1. 保证只执行一次方法
2. 保证对数据的影响只触发一次
```

2. 如何理解分布式事务？

```
1. ACID：原子性、一致性、隔离性、持久性
2. CAP：C（一致性），A（可用性）、P（分区容忍性），一般来说满足CP或AP。
3. BASE：最终一致性
解决方案：
1. seata中间件
2. 消息队列（最终一致性）
3. 补偿事务：
    
```

3. 分布式ID生成有哪几种方案？

```
分布式ID的特性：
1. 唯一性
2. 高可用性

解决方案：
1. UUID：核心算法是依赖机器的网卡、当地时间、一个随机数来生成UUID
2. 数据库自增ID：绝对唯一，如果是两台服务器需要设置不同的步长
3. redis生成：incr，incrby
4. Twriter的雪花算法：根据时间戳+机器ID+序列号生成
```

4. 常见的负载均衡算法？

```
1. 轮询负载均衡算法
2. 加权轮询算法
3. 随机算法
4. 最少连接：哪个服务器链接少就请求
```


