1. 分布式幂等性如何设计？

```
幂等的概念：
一般指方法被多次重复执行所产生的影响和多次执行产生的影响是相同的。
数据库中查和删是没有幂等问题，增和改存在幂等问题。
导致接口被重复调用的场景：
1. 因为用户的重复提交或恶意攻击导致的请求被重复执行
2. 分布式架构中重试机制导致的多次被执行
如何解决：
1. 可以使用数据库的唯一约束去解决幂等性，比如创建订单，订单号肯定是唯一的，设置订单号是
唯一索引，避免一次请求创建多个订单。
2. 使用redis中提供的setnx，针对MQ队列重复消费的场景，一个队列被执行后将这个消息通过
setNx设置到redis中，第二次消费的时候就不会有问题了。
3. 悲观锁：for update，这个不建议使用，有可能影响系统的性能。
4. 乐观锁：version字段，查询时得到一个version，更新时根据这个状态去更新，如果发现这个
状态已经变了，说明已经被人更新过了，则舍弃这个更新操作。
解决思路：
1. 保证只执行一次方法
2. 保证对数据的影响只触发一次
```

2. 如何理解分布式事务？

```
1. ACID：原子性、一致性、隔离性、持久性
2. CAP：C（一致性），A（可用性）、P（分区容忍性），一般来说满足CP或AP。
3. BASE：最终一致性
解决方案：
1. seata中间件（两阶段）
2. 消息队列（最终一致性）
3. 补偿事务（tcc）
```

3. 如何利用补偿型事务处理分布式事务？

```
什么是补偿事务（TCC）
TCC实际上就是采用补偿机制，其核心思想是针对每个操作，都注册一个对应的确认和补偿操作

补偿事务的步骤：
1. Try阶段主要是对业务系统做检测和资源预留
2. confirm阶段主要是对业务进行确认。
3. cancel阶段是在业务执行异常后，需要对业务进行取消回滚。

适合的场景：
1. 业务要求及时性，对敏感性数据这样处理，比如增加货款。

优势：
1. 保证了最终一致性
劣势：
1. 业务耦合度较高，会提高开发成本。
```

4. 如何利用消息队列和事件表处理分布式事务？

```

```

5. 分布式ID生成有哪几种方案？

```
分布式ID的特性：
1. 唯一性
2. 高可用性

解决方案：
1. UUID：核心算法是依赖机器的网卡、当地时间、一个随机数来生成UUID
2. 数据库自增ID：绝对唯一，如果是两台服务器需要设置不同的步长
3. redis生成：incr，incrby
4. Twriter的雪花算法：根据时间戳+机器ID+序列号生成
```

4. 常见的负载均衡算法？

```
1. 轮询负载均衡算法
2. 加权轮询算法 -> 平滑加权轮算算法
3. 随机算法
4. 最少连接（哪个服务器链接少就请求），哪个连接少就向谁发请求
5. 原地址散列：根据请求的ip做hash计算，只要ip不变，那就会访问同一个服务器，有利于做
session信息的维护。
```

5. 常见的限流算法有哪些？

```
1. 计算器(固定窗口)算法
    具体实现：
    通过redis的incr，比如说1分钟限流100个流量，那么第一个进来设置set key 1 ttl 60，
然后第二个流量进来incr加1，如果1分钟内incr超过了100，那么就出发限流策略。
    问题：
    临界问题，限流不够均匀，如果说1分钟内，前50秒来了10个流量，第50秒来了50个流量，第二分钟前10秒
来了60个流量，那么在短短的20秒内就来了110个流量，就没达到效果。
2. 滑动时间窗口算法
    是为了解决固定窗口临界问题，意思是将1分钟粒度缩小，比如1分钟分为1-15,16-30,31-45，
46-60，每个区间只能承载25个流量，然后按照上面的算法设置set key 1 ttl 15，颗粒度越小，
限流越均衡。
3. 漏桶算法
4. 令牌桶算法
    具体实现：
    有一个定时器往一个固定容器（10个）按照恒定的速率（比如100毫秒）往令牌桶中写入令牌，
如果容器中多余10个就抛弃，当请求进来之后需要先获取令牌，有令牌再放行，令牌不足则触发限流
```


