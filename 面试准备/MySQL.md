# 基础

1. char和varchar有什么区别？

```
char: 是定长字符串类型，需要指定长度，指定多少长度就占用多少，和字段值无关。
varchar：是变长字符串类型，也需要指定长度，指定长度是最大占用长度，会根据字段值实际
长度来判断具体占用多少
区别：char比varchar性能更高，因为不用根据具体的值进行扩容。
```

2. 查询的ID在左边补齐7位0

```sql
SELECT LPAD(id, 7, '0') FROM t_user LIMIT 1;
```

3. 查询字段值截取前10位长度的内容，如果本身长度就小于等于10就原样输出，否则最后加上...

```sql
SELECT 
    CASE
    WHEN CHAR_LENGTH(product_name) <= 10 THEN product_name
    ELSE CONCAT(SUBSTRING(product_name, 1, 10),'...')
END AS modified_product_name
FROM product;
```

4. 生成6位随机数

```sql
# 需要向左补齐0，因为生成的随机数可能为0.0011023这样的
select lpad(floor(rand() * 1000000), 6, '0');
```

5. 查询入职天数

```sql
select name, datediff(curdate(), entrydate) as entry_date_num from emp 
order by entry_date_num desc;
```

# 中级

1. 事务的四大特性

```
1. 原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
2. 一致性：事务完成后，必须使所有的数据都保持一致性，通过数据库约束等来保证一致性。
3. 隔离性：数据库系统提供的隔离机制，保证事务在外部并发的影响下不受影响，是独立环境下
运行。
4. 持久性：事务提交或回滚后，数据的改变是永久的。
```

2. 并发的事务问题

```
1. 脏读
    是读取到其他未提交事务的数据
    比如A和B事务，B修改了数据但未提交，A读取到数据已经被修改了。
2. 不可重复读
    一个事务先后读取相同数据，两次数据不一致（和幻读相比，关注的是修改）
    比如A和B事务，A先读到数据，B修改数据已经提交，然后A再次读取发现数据不一致。
3. 幻读
    一个事务先查询没有读取到数据，然后插入，再插入或删除时发现数据已经存在（和不可重复读，关注的是插入和删除）
    比如说A和B事务，A先查询数据不存在，B先插入了数据并提交，A插入数据失败，然后再次查询
发现数据已经存在，仿佛出现了“幻象”
```

3. 事务的隔离级别

```
1. 读未提交
    会出现脏读、不可重复读、幻读
2. 读已提交（默认）
    不会出现脏读，但会出现不可重复读和幻读
3. 可重复读
    不会出现脏读、不可重复读，但会出现幻读
4. 串行化
    不会出现脏读、不可重复读、幻读
从上往下隔离级别依次增加，性能依次下降。
```

4. InnoDB和MyISAM的区别

```
InnoDB：
    1. 支持事务
    2. 行级锁
    3. 外键
    4. 更新、删除操作保持数据完整性首选
MyISAM：
    1. 不支持事务
    2. 表锁
    3. 不支持外键
    4. 主要是写入和读取操作时，对数据完整性、一致性要求不高可以选择
```

5. 为什么InnoDB选择B+Tree

```
1. B+Tree相对于二叉树层级更少，搜索效率更高
2. B+Tree相对于B-Tree，同样B-Tree节点不仅存储指针，而且存储数据，这样依然会导致层级
过高
3. B+Tree相对于Hash，B+Tree支持范围查询以及排序操作
```

6. 索引分类

```
按照功能分类：
    1. 主键索引
    2. 普通索引
    3. 唯一索引
    4. 全文索引
按照存储形式分类：
    1. 聚集索引，主键索引就是聚集索引，最底层子节点中存储了数据，通过索引查找直接返回
    2. 二级索引，普通索引就是二级索引，最底层子节点中只存储了id，还需要去聚集索引中查找
具体的数据，这叫做回表。
```

7. 你在工作中，如何进行SQL性能优化

```
1. 开启慢查询日志
2. explain/desc
```

8. 索引的使用规范有哪些？

```
1. 最左前缀法则，只要用到了就OK，如果从左往右，其中一个没有使用，则后面都会失效
2. 范围查询法则，范围查询右侧的索引将会失效，解决方法是使用>=,<=。
3. 覆盖索引法则，查询字段应该是索引字段，不然会导致再次回表，联合索引。
4. 前缀索引法则，针对较长的字符串，应该要考虑创建前缀索引，
计算前缀长度：
select count(distinct email) / count(*) from tb_user;
设置前缀索引：
create index email_5 on tb_user(email(5));
```

9. 索引失效的场景有哪些？

```
1. 索引列使用了列运算则会使该列索引失效
2. 字符串类型不加引号会导致该列索引失效
3. 模糊查询，"xxx%"不会失效，"%xxx"等会失效
4. or，左右两边都要有索引，不然会导致全部失效
5. 数据分布会影响，比如查询id>0等于全表扫描
```

10. 索引设计的原则有哪些？

```
1. 针对常作为where,order by,group by操作的字段建立索引。
2. 尽量选择区分度高的字段建立索引。
3. 对于字符串较长的字段建立前缀索引。
4. 尽量使用联合索引，减少单列索引，因为联合索引大多数可以使用覆盖索引。
5. 要控制索引数量，过多的索引会导致维护成本增加，影响增删改的效率。
6. 索引列不存储NULL，请设置NOT NULL。
```

11. 索引优化有哪些原则？

```
插入数据优化
    大量数据插入：
    1. 通过批量插入法插入数据
    2. 保证主键按顺序插入，乱序容易导致页分裂
    巨量数据插入：
    1. 使用load指令插入
主键优化
    1. 按顺序插入减少页分裂
    2. 主键避免使用uuid，因为太长了
    3. 避免修改主键的值，容易导致页合并等问题
    4. 尽量软删除，容易导致页合并问题
排序优化
    1. 单列排序需要注意查询字段不要超过索引的字段（使用*肯定会导致回表，filesort)
    2. 单列排序字段如果是联合索引也会使用到索引
    3. 多列排序需要建立联合索引才会生效（比如a,b字段单独建立索引，使用
order by a, b，索引不生效），但要满足最左前缀原则，这里和where不一样，顺序也要保持
一致才会生效。
    4. 如果使用asc、desc会导致filesort，如果非要解决这个问题，需要建立特定索引
create index idx_A_B on table_name(A asc,B desc)，但没有必要。
```


