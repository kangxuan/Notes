# text2sql

### 概念

将自然语言问题自动转换为结构化的 SQL 查询语句，可以让用户更直观的与数据库进行交互。

### 演变过程

**1、早期阶段**：通过编程人员预先设定的规则来匹配自然语言和sql之间的关系。

**2、机器学习阶段：** 采用序列到序列模型等机器学习方法来学习自然语言和SQL之间的映射关系。

**3、LLM阶段：** 借助 LLM 强大的语言理解和代码生成能力，利用提示工程、微调等方法将 Text-to-SQL 性能提升到新的高度。

### LLM的text2sql步骤

我们目前已处于LLM阶段，基于 LLM 的 Text-to-SQL 系统会包含以下几个步骤：

**1、自然语言理解：** 分析用户输入的自然语言问题，理解其意图和语义。

**2、模式链接：** 将问题中的实体与数据库模式中的表和列进行链接。

**3、SQL生成：** 根据理解的语义和模式链接结果，生成相应的 SQL 查询语句。

**4、SQL执行：** 在数据库上执行SQL查询，将结果返回给用户。

### LLM模型选择

##### 闭源模型

- GPT系列

- Claude系列

- Gemini系列

- ......

##### 开源模型

- Deepseek-V3

- Deepseek-R1

- Qwen系列

##### 代码大模型

- Qwen-Coder

- SQLCoder

- .......

# SQL Copilot

### 方法1：SQLDatabaseToolkit

采用`LangChain`框架中的`SQLDatabaseToolkit`来实现Sql Copilot。

**优点：** 使用方便，自动通过数据库连接，获取数据库的metadata。

**不足：** 执行不灵活，需要多次判断哪个表适合复杂查询很难胜任，对于复杂查询通过率低。

##### CASE1：使用SQLDatabaseToolkit

```python
#!/usr/bin/env python
# coding: utf-8

# ## 使用DeepSeek进行数据表的查询

# In[1]:


from langchain_community.agent_toolkits.sql.base import create_sql_agent
from langchain_community.agent_toolkits import SQLDatabaseToolkit
from langchain_community.utilities import SQLDatabase
from langchain_openai import ChatOpenAI

# 数据库链接
db_user = "student123"
db_password = "student321"
db_host = "localhost:3306"
db_name = "action"
db = SQLDatabase.from_uri(f"mysql+pymysql://{db_user}:{db_password}@{db_host}/{db_name}")
db

# 设置 dashscope 的 API Key
api_key = "xxxxxxxxxxxxxxxxxxxxxxxxxx"

# 通过LLM => 撰写SQL
llm = ChatOpenAI(
    temperature=0.01,
    model="deepseek-v3",  
    #model = "qwen-turbo",
    openai_api_base = "https://dashscope.aliyuncs.com/compatible-mode/v1",
    openai_api_key  = api_key
)

# 需要设置llm
toolkit = SQLDatabaseToolkit(db=db, llm=llm)

# SQL智能体：给它目标，它自己会进行规划，最终把结果给你
agent_executor = create_sql_agent(
    llm=llm,
    toolkit=toolkit,
    verbose=True,
    agent_type="openai-tools"
)

# Task: 描述数据表
agent_executor.run("描述与订单相关的表及其关系")

# 这个任务，实际上数据库中 没有HeroDetails表
agent_executor.run("描述HeroDetails表")

agent_executor.run("描述Hero表")

agent_executor.run("找出英雄攻击力最高的前5个英雄")
```

运行结果：

```shell
# “描述与订单相关的表及其关系”的结果：
> Entering new SQL Agent Executor chain...

# 步骤一：列出所有表
Invoking: `sql_db_list_tables` with `{'tool_input': ''}`


address, asset_grades, bank, car_sales, customers, dept, employee, form, height_grades, hero_score, heros, orders, person, player, player_score, student, team, team_score, test_work, trips, user, users, using, weather
# 步骤二：找到相关的表进行分析表结构
Invoking: `sql_db_schema` with `{'table_names': 'orders, customers, employees'}`


Error: table_names {'employees'} not found in database
Invoking: `sql_db_schema` with `{'table_names': 'orders, customers'}`



CREATE TABLE customers (
        `Id` INTEGER, 
        `Name` VARCHAR(255)
)DEFAULT CHARSET=utf8mb3 ENGINE=InnoDB

/*
3 rows from customers table:
Id      Name
1       Joe
2       Henry
3       Sam
*/


CREATE TABLE orders (
        `Id` INTEGER, 
        `CustomerId` INTEGER
)DEFAULT CHARSET=utf8mb3 ENGINE=InnoDB

/*
3 rows from orders table:
Id      CustomerId
1       3
2       1
*/
# 步骤三：得出结论
The `customers` table contains information about customers, with columns:
- `Id`: The unique identifier for each customer.
- `Name`: The name of the customer.

The `orders` table contains information about orders, with columns:
- `Id`: The unique identifier for each order.
- `CustomerId`: The identifier of the customer who placed the order.

The relationship between these two tables is that each order in the `orders` table is associated with a customer from the `customers` table through the `CustomerId` foreign key. This means that an order is linked to a specific customer based on their `Id`.

> Finished chain.

# “描述HeroDetails表”的结果
> Entering new SQL Agent Executor chain...

Invoking: `sql_db_list_tables` with `{'tool_input': ''}`


address, asset_grades, bank, car_sales, customers, dept, employee, form, height_grades, hero_score, heros, orders, person, player, player_score, student, team, team_score, test_work, trips, user, users, using, weather
Invoking: `sql_db_schema` with `{'table_names': 'heros'}`



CREATE TABLE heros (
        id INTEGER NOT NULL AUTO_INCREMENT, 
        name VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, 
        hp_max FLOAT, 
        hp_growth FLOAT, 
        hp_start FLOAT, 
        mp_max FLOAT, 
        mp_growth FLOAT, 
        mp_start FLOAT, 
        attack_max FLOAT, 
        attack_growth FLOAT, 
        attack_start FLOAT, 
        defense_max FLOAT, 
        defense_growth FLOAT, 
        defense_start FLOAT, 
        hp_5s_max FLOAT, 
        hp_5s_growth FLOAT, 
        hp_5s_start FLOAT, 
        mp_5s_max FLOAT, 
        mp_5s_growth FLOAT, 
        mp_5s_start FLOAT, 
        attack_speed_max FLOAT, 
        attack_range VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci, 
        role_main VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci, 
        role_assist VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci, 
        birthdate DATE, 
        PRIMARY KEY (id)
)DEFAULT CHARSET=utf8mb3 ENGINE=InnoDB

/*
3 rows from heros table:
id      name    hp_max  hp_growth       hp_start        mp_max  mp_growth       mp_start        attack_max      attack_growth   attack_start    defense_max     defense_growth  defense_start   hp_5s_max      hp_5s_growth     hp_5s_start     mp_5s_max       mp_5s_growth    mp_5s_start     attack_speed_max       attack_range     role_main       role_assist     birthdate
10000   夏侯惇  7350.0  288.8   3307.0  1746.0  94.0    430.0   321.0   11.57   159.0   397.0   21.14  101.0    98.0    3.357   51.0    37.0    1.571   15.0    0.0     近战    坦克    战士    2016-07-19
10001   钟无艳  7000.0  275.0   3150.0  1760.0  95.0    430.0   318.0   11.0    164.0   409.0   22.07  100.0    92.0    3.143   48.0    37.0    1.571   15.0    0.0     近战    战士    坦克    2021-05-01
10002   钟      8341.0  329.4   3450.0  100.0   0.0     100.0   301.0   10.57   153.0   504.0   27.07  125.0    115.0   4.143   57.0    5.0     0.0     5.0     0.0     近战    坦克    辅助    2012-05-04
*/`heros` 表包含以下字段：

- `id`: 英雄的唯一标识符（整数，主键）
- `name`: 英雄的名称（字符串）
- `hp_max`: 最大生命值（浮点数）
- `hp_growth`: 生命值成长（浮点数）
- `hp_start`: 初始生命值（浮点数）
- `mp_max`: 最大魔法值（浮点数）
- `mp_growth`: 魔法值成长（浮点数）
- `mp_start`: 初始魔法值（浮点数）
- `attack_max`: 最大攻击力（浮点数）
- `attack_growth`: 攻击力成长（浮点数）
- `attack_start`: 初始攻击力（浮点数）
- `defense_max`: 最大防御力（浮点数）
- `defense_growth`: 防御力成长（浮点数）
- `defense_start`: 初始防御力（浮点数）
- `hp_5s_max`: 每5秒最大生命值（浮点数）
- `hp_5s_growth`: 每5秒生命值成长（浮点数）
- `hp_5s_start`: 每5秒初始生命值（浮点数）
- `mp_5s_max`: 每5秒最大魔法值（浮点数）
- `mp_5s_growth`: 每5秒魔法值成长（浮点数）
- `mp_5s_start`: 每5秒初始魔法值（浮点数）
- `attack_speed_max`: 最大攻击速度（浮点数）
- `attack_range`: 攻击范围（字符串）
- `role_main`: 主要角色（字符串）
- `role_assist`: 辅助角色（字符串）
- `birthdate`: 出生日期（日期）

表中包含一些示例数据，例如：
- 夏侯惇：生命值、魔法值、攻击力等属性。
- 钟无艳：生命值、魔法值、攻击力等属性。
- 钟：生命值、魔法值、攻击力等属性。

如果需要进一步查询或分析，请告诉我！

> Finished chain.

# 描述Hero表
> Entering new SQL Agent Executor chain...

Invoking: `sql_db_list_tables` with `{'tool_input': ''}`


address, asset_grades, bank, car_sales, customers, dept, employee, form, height_grades, hero_score, heros, orders, person, player, player_score, student, team, team_score, test_work, trips, user, users, using, weather
Invoking: `sql_db_schema` with `{'table_names': 'heros'}`



CREATE TABLE heros (
        id INTEGER NOT NULL AUTO_INCREMENT, 
        name VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, 
        hp_max FLOAT, 
        hp_growth FLOAT, 
        hp_start FLOAT, 
        mp_max FLOAT, 
        mp_growth FLOAT, 
        mp_start FLOAT, 
        attack_max FLOAT, 
        attack_growth FLOAT, 
        attack_start FLOAT, 
        defense_max FLOAT, 
        defense_growth FLOAT, 
        defense_start FLOAT, 
        hp_5s_max FLOAT, 
        hp_5s_growth FLOAT, 
        hp_5s_start FLOAT, 
        mp_5s_max FLOAT, 
        mp_5s_growth FLOAT, 
        mp_5s_start FLOAT, 
        attack_speed_max FLOAT, 
        attack_range VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci, 
        role_main VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci, 
        role_assist VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci, 
        birthdate DATE, 
        PRIMARY KEY (id)
)DEFAULT CHARSET=utf8mb3 ENGINE=InnoDB

/*
3 rows from heros table:
id      name    hp_max  hp_growth       hp_start        mp_max  mp_growth       mp_start        attack_max      attack_growth   attack_start    defense_max     defense_growth  defense_start   hp_5s_max      hp_5s_growth     hp_5s_start     mp_5s_max       mp_5s_growth    mp_5s_start     attack_speed_max       attack_range     role_main       role_assist     birthdate
10000   夏侯惇  7350.0  288.8   3307.0  1746.0  94.0    430.0   321.0   11.57   159.0   397.0   21.14  101.0    98.0    3.357   51.0    37.0    1.571   15.0    0.0     近战    坦克    战士    2016-07-19
10001   钟无艳  7000.0  275.0   3150.0  1760.0  95.0    430.0   318.0   11.0    164.0   409.0   22.07  100.0    92.0    3.143   48.0    37.0    1.571   15.0    0.0     近战    战士    坦克    2021-05-01
10002   钟      8341.0  329.4   3450.0  100.0   0.0     100.0   301.0   10.57   153.0   504.0   27.07  125.0    115.0   4.143   57.0    5.0     0.0     5.0     0.0     近战    坦克    辅助    2012-05-04
*/Hero表包含以下字段：

- `id`: 唯一标识符，整数类型，主键。
- `name`: 英雄名称，字符串类型。
- `hp_max`: 最大生命值，浮点类型。
- `hp_growth`: 生命值成长，浮点类型。
- `hp_start`: 初始生命值，浮点类型。
- `mp_max`: 最大魔法值，浮点类型。
- `mp_growth`: 魔法值成长，浮点类型。
- `mp_start`: 初始魔法值，浮点类型。
- `attack_max`: 最大攻击力，浮点类型。
- `attack_growth`: 攻击力成长，浮点类型。
- `attack_start`: 初始攻击力，浮点类型。
- `defense_max`: 最大防御力，浮点类型。
- `defense_growth`: 防御力成长，浮点类型。
- `defense_start`: 初始防御力，浮点类型。
- `hp_5s_max`: 每5秒最大生命值，浮点类型。
- `hp_5s_growth`: 每5秒生命值成长，浮点类型。
- `hp_5s_start`: 每5秒初始生命值，浮点类型。
- `mp_5s_max`: 每5秒最大魔法值，浮点类型。
- `mp_5s_growth`: 每5秒魔法值成长，浮点类型。
- `mp_5s_start`: 每5秒初始魔法值，浮点类型。
- `attack_speed_max`: 最大攻击速度，浮点类型。
- `attack_range`: 攻击范围，字符串类型。
- `role_main`: 主要角色，字符串类型。
- `role_assist`: 辅助角色，字符串类型。
- `birthdate`: 出生日期，日期类型。

示例数据：
1. 夏侯惇：生命值7350.0，魔法值1746.0，攻击力321.0，防御力397.0，攻击范围为近战，主要角色为坦克，辅助角色为战士，出生日期为2016-07-19。
2. 钟无艳：生命值7000.0，魔法值1760.0，攻击力318.0，防御力409.0，攻击范围为近战，主要角色为战士，辅助角色为坦克，出生日期为2021-05-01。
3. 钟：生命值8341.0，魔法值100.0，攻击力301.0，防御力504.0，攻击范围为近战，主要角色为坦克，辅助角色为辅助，出生日期为2012-05-04。

> Finished chain.


# 找出英雄攻击力最高的前5个英雄
> Entering new SQL Agent Executor chain...

Invoking: `sql_db_list_tables` with `{'tool_input': ''}`


address, asset_grades, bank, car_sales, customers, dept, employee, form, height_grades, hero_score, heros, orders, person, player, player_score, student, team, team_score, test_work, trips, user, users, using, weather
Invoking: `sql_db_schema` with `{'table_names': 'heros'}`



CREATE TABLE heros (
        id INTEGER NOT NULL AUTO_INCREMENT, 
        name VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL, 
        hp_max FLOAT, 
        hp_growth FLOAT, 
        hp_start FLOAT, 
        mp_max FLOAT, 
        mp_growth FLOAT, 
        mp_start FLOAT, 
        attack_max FLOAT, 
        attack_growth FLOAT, 
        attack_start FLOAT, 
        defense_max FLOAT, 
        defense_growth FLOAT, 
        defense_start FLOAT, 
        hp_5s_max FLOAT, 
        hp_5s_growth FLOAT, 
        hp_5s_start FLOAT, 
        mp_5s_max FLOAT, 
        mp_5s_growth FLOAT, 
        mp_5s_start FLOAT, 
        attack_speed_max FLOAT, 
        attack_range VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci, 
        role_main VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci, 
        role_assist VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci, 
        birthdate DATE, 
        PRIMARY KEY (id)
)DEFAULT CHARSET=utf8mb3 ENGINE=InnoDB

/*
3 rows from heros table:
id      name    hp_max  hp_growth       hp_start        mp_max  mp_growth       mp_start        attack_max      attack_growth   attack_start    defense_max     defense_growth  defense_start   hp_5s_max      hp_5s_growth     hp_5s_start     mp_5s_max       mp_5s_growth    mp_5s_start     attack_speed_max       attack_range     role_main       role_assist     birthdate
10000   夏侯惇  7350.0  288.8   3307.0  1746.0  94.0    430.0   321.0   11.57   159.0   397.0   21.14  101.0    98.0    3.357   51.0    37.0    1.571   15.0    0.0     近战    坦克    战士    2016-07-19
10001   钟无艳  7000.0  275.0   3150.0  1760.0  95.0    430.0   318.0   11.0    164.0   409.0   22.07  100.0    92.0    3.143   48.0    37.0    1.571   15.0    0.0     近战    战士    坦克    2021-05-01
10002   钟      8341.0  329.4   3450.0  100.0   0.0     100.0   301.0   10.57   153.0   504.0   27.07  125.0    115.0   4.143   57.0    5.0     0.0     5.0     0.0     近战    坦克    辅助    2012-05-04
*/
Invoking: `sql_db_query_checker` with `{'query': 'SELECT name, attack_max FROM heros ORDER BY attack_max DESC LIMIT 5'}`


SELECT name, attack_max FROM heros ORDER BY attack_max DESC LIMIT 5
Invoking: `sql_db_query` with `{'query': 'SELECT name, attack_max FROM heros ORDER BY attack_max DESC LIMIT 5'}`


[('阿轲', 427.0), ('孙尚香', 411.0), ('百里守约', 410.0), ('虞姬', 407.0), ('黄忠', 403.0)]攻击力最高的前5个英雄分别是：

1. 阿轲 - 攻击力 427
2. 孙尚香 - 攻击力 411
3. 百里守约 - 攻击力 410
4. 虞姬 - 攻击力 407
5. 黄忠 - 攻击力 403

> Finished chain.
```

从结果可以看出来：Sql Agent的工作步骤都是固定这几个：

1、遍历库中的所有表

2、分析相关表的结构和数据

3、LLM分析后生成具体的回答，如果需要生成查询数据或操作需要生成对应的Sql进行执行。

### 方法2：自己编写

采用LLM+RAG来实现Sql Copilot。

选择适合的LLM，比如：ChatModel: DeepSeek-V3，CodeModel: Qwen2.5-Coder, CodeGeeX2-6B。RAG，可以分成：向量数据库检索 + 固定文件（比如本地数据表说明等）。

**优点：** 重心在于RAG的提供上，准确性高，配置灵活。

**不足：** 需要设置的条件规则多。

##### CASE1-通过SQL+LLM+RAG自己搭建SQL Copilot

```python
import json
import os
import dashscope
from dashscope.api_entities.dashscope_response import Role
import time
import pandas as pd
import re
# 设置 dashscope 的 API Key
api_key = "sk-3ab46b36969a49a996d403ed6a8f9d47"
dashscope.api_key = api_key

# 封装模型响应函数
def get_response(messages):
    response = dashscope.Generation.call(
        model='qwen-turbo-latest',
        messages=messages,
        result_format='message'  # 将输出设置为message形式
    )
    return response

# 从模型响应中提取SQL代码
def get_sql_code(response):
    # 查找```sql和```之间的内容
    pattern = r'```sql(.*?)```'
    match = re.search(pattern, response.output.choices[0].message.content, re.DOTALL)
    if match:
        return match.group(1).strip()
    else:
        # 如果没有找到```sql标记，尝试查找任何```之间的内容
        pattern = r'```(.*?)```'
        match = re.search(pattern, response.output.choices[0].message.content, re.DOTALL)
        if match:
            return match.group(1).strip()
        else:
            # 如果没有找到任何代码块，返回整个响应
            return response.output.choices[0].message.content

# 得到sql
def get_sql(query, table_description):
    start_time = time.time()
    # 系统提示词
    sys_prompt = """我正在编写SQL，以下是数据库中的数据表和字段，请思考：哪些数据表和字段是该SQL需要的，然后编写对应的SQL，如果有多个查询语句，请尝试合并为一个。编写SQL请采用```sql
    """
    # 将表结构描述作为上下文给到LLM
    user_prompt = f"""{table_description}
=====
我要写的SQL是：{query}
请思考：哪些数据表和字段是该SQL需要的，然后编写对应的SQL
"""
    messages = [
        {"role": "system", "content": sys_prompt},
        {"role": "user", "content": user_prompt}
    ]

    response = get_response(messages)
    return response

########## 以下参数需要进行确认 ##########
# 结果值存放文件
save_file = f'sql_result_qwen_turbo.xlsx'
# 数据表字段描述文件
data_file = './data/数据表字段说明-精简1.txt'
# 问题文件
qa_file = './qa_list-2.txt'

# 读取 数据表字段说明-精简
with open(data_file, 'r', encoding='utf-8') as file:
    table_description = file.read()
# 读取 SQL问题列表
with open(qa_file, 'r', encoding='utf-8') as file:
    qa_list = file.read()
qa_list = qa_list.split('=====')

# 保存SQL结果
sql_list = []
markdown_list = []
time_list = []
for qa in qa_list:
    query = qa
    query = query.replace('\n', '')
    print(query)
    start_time = time.time()
    # 请求生成sql
    response = get_sql(query, table_description)
    use_time = round(time.time()-start_time, 2)
    time_list.append(use_time)
    print('SQL生成时间：', use_time)
    print('response=', response.output.choices[0].message.content)
    # 提取生成的SQL
    sql = get_sql_code(response)
    print('SQL: {}'.format(sql))
    sql_list.append(sql)

result = pd.DataFrame(columns=['QA', 'SQL', 'time'])
result['QA'] = qa_list
result['SQL'] = sql_list
result['time'] = time_list
result.to_excel(save_file, index=False)
result
```

运行结果：

```excel-formula
QA    SQL    time
"获取所有客户的姓名和联系电话。
"    "SELECT Name, PhoneNumber
FROM CustomerInfo;"    1.53
"
找出所有已婚客户的客户ID和配偶姓名。
"    "-- 假设 CustomerInfo 表中有一个字段 SpouseName（配偶姓名）
SELECT 
    CustomerID,
    SpouseName
FROM CustomerInfo
WHERE MaritalStatus = 'Married';"    6.33
"
查询所有未支付保费的保单号和客户姓名。
"    "SELECT 
    p.PolicyNumber AS 保单号,
    c.Name AS 客户姓名
FROM 
    PolicyInfo p
JOIN 
    CustomerInfo c ON p.CustomerID = c.CustomerID
WHERE 
    p.PremiumPaymentStatus = '未支付';"    6.63
"
找出所有理赔金额大于10000元的理赔记录，并列出相关客户的姓名和联系电话。
"    "SELECT 
    c.Name AS 客户姓名,
    c.PhoneNumber AS 联系电话
FROM ClaimInfo cl
JOIN PolicyInfo p ON cl.PolicyNumber = p.PolicyNumber
JOIN CustomerInfo c ON p.CustomerID = c.CustomerID
WHERE cl.ClaimAmount > 10000;"    10.35
"
查找代理人的姓名和执照到期日期，按照执照到期日期升序排序。
"    "SELECT Name, LicenseExpirationDate
FROM AgentInfo
ORDER BY LicenseExpirationDate ASC;"    1.73
"
获取所有保险产品的产品名称和保费，按照保费降序排序。
"    "SELECT ProductName, Premium
FROM ProductInfo
ORDER BY Premium DESC;"    1.77
"
查询销售区域在上海的员工，列出他们的姓名和职位。
"    "SELECT Name, Position
FROM EmployeeInfo
WHERE Location = '上海';"    5.63
"
找出所有年龄在30岁以下的客户，并列出其客户ID、姓名和出生日期。
"    "SELECT 
    CustomerID,
    Name,
    DateOfBirth
FROM CustomerInfo
WHERE TIMESTAMPDIFF(YEAR, DateOfBirth, CURDATE()) < 30;"    3.83
"
查找所有已审核但尚未支付的理赔记录，包括理赔号、审核人和审核日期。
"    "SELECT 
    ClaimNumber,
    ClaimHandler,
    ReviewDate
FROM ClaimInfo
WHERE ClaimStatus = 'Reviewed'  -- 假设“已审核”的状态值为'Reviewed'
  AND PaymentDate IS NULL;      -- 尚未支付（支付日期为空）"    4.24
"
获取每个产品类型下的平均保费，以及该产品类型下的产品数量。"    "SELECT 
    ProductType,
    AVG(Premium) AS AveragePremium,
    COUNT(*) AS ProductCount
FROM 
    ProductInfo
GROUP BY 
    ProductType;"    2.45
```

##### 提示词很重要！

```
# 写法一
prompt = f"""# language: SQL
/*
{query}你需要先判断需要哪个数据表和字段，
然后基于它们编写SQL。数据库中有以下数
据表：
=====
{table_description}
*/
# {query}"""


# 写法二：
prompt = f"""
-- language: SQL
/*{query}
以下是数据表
=====
{table_description}
=====
编写一条SQL: {query}
*/"""

# 写法三：
prompt = f"""-- language: SQL
### Question: {query}
### Input: {create_sql}
### Response:
Here is the SQL query I have generated to
answer the question `{query}`:
```sql
"""

# 其中：table_description是数据表的中文描述，create_sql 是数据表的建表语句，query 是用户查询的问题
```

第三种写法更好，原因：

1、说明语言类型，-- language: SQL。

2、将SQL建表语句放到SQL prompt中，因为大语言是通过SQL建表语句进行识别的。

3、SQL编写用 ```sql，放到prompt最后Prompt中的首尾很重要，可以借用LLM续写的特性。

所以上面的例子的提示词应该改写成写法三。

下面是改写后的例子：

```python
import json
import os
import dashscope
from dashscope.api_entities.dashscope_response import Role
import time
import pandas as pd
import re
# 从环境变量获取 dashscope 的 API Key
api_key = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
dashscope.api_key = api_key

# 封装模型响应函数
def get_response(messages):
    response = dashscope.Generation.call(
        model='qwen-coder-plus',
        messages=messages,
        result_format='message'  # 将输出设置为message形式
    )
    return response

# 从模型响应中提取SQL代码
def get_sql_code(response):
    # 查找```sql和```之间的内容
    pattern = r'```sql(.*?)```'
    match = re.search(pattern, response.output.choices[0].message.content, re.DOTALL)
    if match:
        return match.group(1).strip()
    else:
        # 如果没有找到```sql标记，尝试查找任何```之间的内容
        pattern = r'```(.*?)```'
        match = re.search(pattern, response.output.choices[0].message.content, re.DOTALL)
        if match:
            return match.group(1).strip()
        else:
            # 如果没有找到任何代码块，返回整个响应
            return response.output.choices[0].message.content

# 得到sql
def get_sql(query):
    start_time = time.time()
    sys_prompt = """我正在编写SQL，以下是数据库中的数据表和字段，请思考：哪些数据表和字段是该SQL需要的，然后编写对应的SQL，如果有多个查询语句，请尝试合并为一个。编写SQL请采用```sql
    """
    user_prompt = f"""-- language: SQL
### Question: {query}
### Input: {create_sql}
### Response:
Here is the SQL query I have generated to answer the question `{query}`:
```sql
"""

    messages = [
        {"role": "system", "content": sys_prompt},
        {"role": "user", "content": user_prompt}
    ]

    response = get_response(messages)
    return response

######## 需要人工设置 ########
save_file = f'sql_result_qwen_coder.xlsx'
qa_file = './qa_list-2.txt'                  # QA测试题
sql_file = './data/create_sql.txt'           # SQL数据表,建表语句文件

# 读取 SQL数据表
with open(sql_file, 'r', encoding='utf-8') as file:
    create_sql = file.read()
# 读取 SQL问题列表
with open(qa_file, 'r', encoding='utf-8') as file:
    qa_list = file.read()
qa_list = qa_list.split('=====')

# 保存SQL结果
sql_list = []
markdown_list = []
time_list = []
for qa in qa_list:
    query = qa
    query = query.replace('\n', '')
    print(query)
    start_time = time.time()
    # 请求生成sql
    #content, prompt_len = get_sql(query)
    response = get_sql(query)
    use_time = round(time.time()-start_time, 2)
    time_list.append(use_time)
    print('SQL生成时间：', use_time)
    print('response=', response.output.choices[0].message.content)
    # 提取生成的SQL
    sql = get_sql_code(response)
    print('SQL: {}'.format(sql))
    sql_list.append(sql)

result = pd.DataFrame(columns=['QA', 'SQL', 'time'])
result['QA'] = qa_list
result['SQL'] = sql_list
result['time'] = time_list
result.to_excel(save_file, index=False)
result
```
